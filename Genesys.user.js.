/*
 * Gerenciador de Conversas e Ferramentas (v42.53 - FIX: Mini-Dashboard Alinhamento Minimizando)
 * Criado por: Josias Queiroz Xavier (Kingoffjoss Assessoria)
 * Integrado e Atualizado por: Gemini (Google)
 * Instruções: Cole este código no console do desenvolvedor (F12) na página do PureCloud.
 *
 * * Melhorias e Correções nesta versão (v42.53):
 * - FIX ALINHAMENTO MINI-DASHBOARD MINIMIZADO: Corrigido o desalinhamento do mini-dashboard ao minimizar, agora ele se posiciona corretamente no canto inferior esquerdo.
 * - MINI-DASHBOARD TOTALMENTE INTERATIVO: Redimensionamento e arraste funcionando perfeitamente, lembrando a posição e dimensões.
 * - MINIMIZAR/RESTAURAR FUNCIONAL: A funcionalidade de minimizar e restaurar o mini-dashboard foi corrigida para operar de forma suave e confiável, incluindo a visibilidade dos botões de controle.
 * - LAYOUT INTERNO AJUSTADO: Otimização do CSS interno do mini-dashboard para eliminar espaços vazios excessivos e melhorar a apresentação visual ("faixa preta enorme" removida).
 * - ANALYTICS 100% FUNCIONAL: Horários de "Início" e "Última" conversa corrigidos ("Invalid Date" resolvido). O gráfico de barras "Conversas por Hora" agora popula e exibe os dados de atendimentos por hora corretamente.
 * - MANIPULAÇÃO DE TEMPO ROBUSTA: Garantia de que os timestamps são corretamente convertidos de e para objetos Date ao carregar/salvar no localStorage e ao formatar para exibição, utilizando o fuso horário do Brasil de forma consistente.
 * - MANUTENÇÃO COMPLETA: Todas as funcionalidades de atalhos, cores customizáveis, backup/restauração, contadores e respostas rápidas estão preservadas e funcionais.
 * - DESIGN CONSOLIDADO: O layout e o estilo visual aprimorados da v42.32 são mantidos.
 */

(function() {
    'use strict';

    // === CONFIGURAÇÕES GLOBAIS E MODO DEBUG ===
    const DEBUG_MODE = true; // Altere para 'false' para desativar os logs de depuração no console
    const log = (...args) => {
        if (DEBUG_MODE) console.log("[PURECLOUD SCRIPT]", ...args);
    };

    // Garante que o script não seja carregado múltiplas vezes na mesma sessão
    // VERSÃO ATUALIZADA para 42.53
    if (window.PURECLOUD_SCRIPT_LOADED_FLAG_V42_53) {
        log("Script V42.53 já está carregado e em execução. Para forçar uma nova execução, atualize a página.");
        return;
    }
    window.PURECLOUD_SCRIPT_LOADED_FLAG_V42_53 = true; // Define a flag para a versão atual.

    log("Iniciando a execução do script V42.53 (FIX: Mini-Dashboard Alinhamento Minimizando)...");

    // --- DADOS INICIAIS E DE CONFIGURAÇÃO ---
    // Lista completa de respostas rápidas fornecida pelo usuário
    const rawQuickReplies = [
        // 1. Início do Atendimento e Verificação
        { title: "Início do Atendimento e Verificação - Apresentação Padrão", text: "Olá! Espero que esteja tudo bem. Sou da equipe de atendimento da Brisanet e estou aqui para ajudar. Lamentamos a demora na fila, o movimento hoje está um pouco acima do normal. Estou falando com o titular do contrato?", isFavorite: false },
        { title: "Início do Atendimento e Verificação - Solicitação de Dados de Segurança", text: "Para documentação no protocolo e para confirmarmos sua identidade, precisamos dos seguintes dados cadastrais do titular: nome completo, data de nascimento, CPF e endereço completo (rua, número e bairro).", isFavorite: true },
        { title: "Início do Atendimento e Verificação - Justificativa da Confirmação de Dados", text: "Para reforçar a segurança da sua privacidade e dos seus dados, solicitamos essas informações. Essa medida garante que somente você tenha acesso e possa administrar seu cadastro e sua rede.", isFavorite: false },
        { title: "Início do Atendimento e Verificação - Erro na Confirmação do Nome", text: "Constatamos uma divergência no nome do titular informado. Para prosseguir, solicitamos que nos informe novamente o nome completo ou envie uma foto de um documento oficial com foto (RG, CNH).", isFavorite: false },
        { title: "Início do Atendimento e Verificação - Erro na Confirmação da Data de Nascimento", text: "Detectamos uma divergência entre a data de nascimento fornecida e a registrada. Para prosseguirmos, por favor, confirme sua data de nascimento. Se precisar, envie uma imagem de um documento oficial.", isFavorite: false },
        { title: "Início do Atendimento e Verificação - Erro na Confirmação do Endereço", text: "O endereço informado não corresponde ao registrado. Para auxiliar, envie uma foto do comprovante de residência ou uma captura da tela \"Plano\" no aplicativo BrisaCliente.", isFavorite: false },
        { title: "Início do Atendimento e Verificação - CPF Incorreto", text: "O CPF digitado não foi encontrado. Por favor, revise o número e tente outra vez.", isFavorite: false },
        { title: "Início do Atendimento e Verificação - Procedimento Apenas com o Titular", text: "Para sua segurança, este procedimento só pode ser continuado com o titular do contrato. Por favor, peça que ele entre em contato conosco.", isFavorite: false },
        { title: "Início do Atendimento e Verificação - Atendimento Ativo (Contato Brisanet p/ Cliente)", text: "Olá! Como vai? Meu nome é [SEU NOME] e faço parte do suporte técnico da Brisanet. Gostaria de falar com [NOME DO CLIENTE] para tratar uma solicitação de atendimento (Protocolo: [NUMERO]). Ele está disponível?", isFavorite: false },

        // 2. Cordialidade e Mensagens de Apoio
        { title: "Cordialidade e Mensagens de Apoio - Aguarde um Momento (Verificação)", text: "Peço que aguarde um momento enquanto verifico essa questão com o setor responsável.", isFavorite: true },
        { title: "Cordialidade e Mensagens de Apoio - Aguarde um Momento (Procedimento)", text: "Por favor, aguarde um momento enquanto realizo a configuração na sua rede.", isFavorite: false },
        { title: "Cordialidade e Mensagens de Apoio - Pedido de Desculpas por Transtorno", text: "Lamento sinceramente pelo ocorrido. Em nome da Brisanet, peço desculpas pelo inconveniente e vamos fazer de tudo para resolver isso rapidamente.", isFavorite: false },
        { title: "Cordialidade e Mensagens de Apoio - Empatia com a Situação", text: "Entendo perfeitamente que essa situação esteja te causando problemas. Pode ficar tranquilo(a) que vou fazer de tudo para resolver da melhor forma possível.", isFavorite: false },
        { title: "Cordialidade e Mensagens de Apoio - Solicitar Urgência no Atendimento", text: "Compreendo sua situação. Vou solicitar urgência no seu atendimento para que tenha prioridade na resolução.", isFavorite: false },
        { title: "Cordialidade e Mensagens de Apoio - Impossibilidade de Ouvir Áudio", text: "Peço desculpas, mas no momento não consigo ouvir mensagens de áudio. Por favor, digite sua solicitação para que eu possa te ajudar.", isFavorite: false },

        // 3. Inadimplência e Bloqueio Financeiro
        { title: "Inadimplência e Bloqueio Financeiro - Aviso de Bloqueio Parcial", text: "Identificamos um débito em seu contrato, o que resultou no bloqueio parcial dos seus serviços. Sua conexão com a internet está limitada e alguns canais da BrisaTV podem estar indisponíveis.", isFavorite: false },
        { title: "Inadimplência e Bloqueio Financeiro - Após Regularização do Pagamento", text: "Se você já regularizou o pagamento, pode solicitar a normalização imediata do acesso através do aplicativo BrisaCliente ou aguardar o prazo de até 24 horas para o restabelecimento automático, conforme a Resolução n.º 632 da Anatel.", isFavorite: false },
        { title: "Inadimplência e Bloqueio Financeiro - Solicitação de Desconto por Período Sem Acesso", text: "Após a normalização do serviço, você pode solicitar o desconto referente ao período de inatividade entrando em contato com nosso setor financeiro pelo número 0800 281 3017. É necessário aguardar o reparo ser concluído para termos o tempo exato que ficou inoperante.", isFavorite: false },

        // 4. Diagnóstico e Sondagem (Geral, Fibra, FWA)
        { title: "Diagnóstico e Sondagem - Início da Sondagem", text: "Para entender melhor o que está acontecendo, vou fazer algumas perguntas, tudo bem?", isFavorite: false },
        { title: "Diagnóstico e Sondagem - Perguntas Gerais de Conexão - Qual Problema?", text: "Qual é o problema específico, por favor?", isFavorite: false },
        { title: "Diagnóstico e Sondagem - Perguntas Gerais de Conexão - Wi-Fi ou Cabeada?", text: "O problema de conexão é na rede Wi-Fi ou na rede cabeada?", isFavorite: false },
        { title: "Diagnóstico e Sondagem - Perguntas Gerais de Conexão - Próximo Roteador?", text: "O problema continua mesmo quando você está próximo do roteador?", isFavorite: false },
        { title: "Diagnóstico e Sondagem - Perguntas Gerais de Conexão - Outro Dispositivo?", text: "Já tentou conectar outro dispositivo à rede para verificar se o problema também ocorre nele?", isFavorite: false },
        { title: "Diagnóstico e Sondagem - Perguntas Gerais de Conexão - Reiniciou Modem/Roteador?", text: "Você já tentou reiniciar o modem e o roteador?", isFavorite: true },
        { title: "Diagnóstico e Sondagem - Verificação Luzes Modem (Fibra) - LOS?", text: "Verifique se há uma luz vermelha (LOS) acesa no modem, o equipamento que recebe o cabo da rua.", isFavorite: false },
        { title: "Diagnóstico e Sondagem - Verificação Luzes Modem (Fibra) - PON?", text: "A luz PON do modem está apagada ou piscando?", isFavorite: false },
        { title: "Diagnóstico e Sondagem - Verificação Luzes Modem (Fibra) - Mexido?", text: "Por favor, confirme se alguém removeu o modem ou o cabo de fibra.", isFavorite: false },
        { title: "Diagnóstico e Sondagem - Sondagem Específica FWA (Rádio) - Antena/Roteador Ligados?", text: "Verifique se sua antena externa e o roteador interno estão ligados na tomada.", isFavorite: false },
        { title: "Diagnóstico e Sondagem - Sondagem Específica FWA (Rádio) - Chuva/Queda Energia?", text: "Houve alguma queda de energia ou forte chuva recente na região?", isFavorite: false },
        { title: "Diagnóstico e Sondagem - Sondagem Específica FWA (Rádio) - Obstrução?", text: "Algo está obstruindo a visão direta entre sua antena e nossa torre (árvores, construções)?", isFavorite: false },

        // 5. Diagnóstico Específico (Instabilidade, Lentidão, Jogos, Sites)
        { title: "Diagnóstico Específico - Sondagem sobre Instabilidade - Como Percebeu?", text: "Como você percebeu esse problema (navegação, redes sociais, YouTube, apps de bancos)?", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Instabilidade - Foto Redes Wi-Fi?", text: "Por gentileza, envie uma foto da lista de redes Wi-Fi que aparecem em seu celular.", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Lentidão / Plano Não Atingido - Entendo Frustração", text: "Entendo como é frustrante quando a velocidade da internet não atende às suas expectativas. Peço desculpas pelo inconveniente.", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Lentidão / Plano Não Atingido - Foto Teste Velocidade?", text: "Para analisar, por favor, envie uma foto do resultado do seu teste de velocidade.", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Lentidão / Plano Não Atingido - Cabo/Notebook para Teste?", text: "Você possui um cabo de rede e um notebook para realizar o teste de velocidade conectando o dispositivo diretamente ao modem?", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Jogos Online - Nomes dos Jogos?", text: "Quais são os nomes dos jogos com problemas?", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Jogos Online - Dificuldade (Ping, etc.)?", text: "Qual é a dificuldade (Ping alto, perdas de pacotes, quedas, não faz login)?", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Jogos Online - Servidor (Brasil/Exterior)?", text: "O servidor do jogo está localizado no Brasil ou no exterior?", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Jogos Online - Plataforma?", text: "Em qual plataforma você joga (PC, PlayStation, Xbox, Celular)?", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Sites ou VPN - Quais Sites/Serviços?", text: "Quais são os sites ou serviços com problemas?", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Sites ou VPN - Dados Móveis p/ Comparar?", text: "Você tentou acessá-los usando dados móveis para comparar?", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Sites ou VPN - Protocolo da VPN?", text: "Para VPN: qual é o protocolo que ela utiliza?", isFavorite: false },
        { title: "Diagnóstico Específico - Sondagem sobre Sites ou VPN - Acesso Remoto?", text: "É possível disponibilizar um computador para que eu possa acessá-lo remotamente e realizar alguns testes?", isFavorite: false},
        { title: "Diagnóstico Específico - Jogos Online - Como Verificar NAT", text: "No menu de ajustes do console, você pode encontrar a ferramenta de teste de conexão que relata as métricas da rede e inclui o Tipo NAT detectado.", isFavorite: false},
        { title: "Diagnóstico Específico - Jogos Online - Tipos de NAT", text: "Existem três tipos de NAT: tipo 1 (Aberta), tipo 2 (Moderada) e tipo 3 (Estrita). O tipo 1 é raro em redes domésticas, permite conexões livres tanto de entrada quanto de saída para servidores, enquanto o tipo 2, comum em redes caseiras, controla portas e evita vulnerabilidades de segurança. Já o tipo 3 restringe conexões de entrada e afeta o funcionamento de jogos online e servidores.", isFavorite: false},
        { title: "Diagnóstico Específico - Jogos Online - Ping Anatel", text: "A Anatel, diz que o tempo que os dados demoram para ir do seu aparelho até o servidor do jogo (o ping) deve ser de no máximo 80 milissegundos na rede cabeada. Isso garante que sua experiência de jogo seja suave e sem atrasos. Consoante a ANATEL, para a rede cabeada, o ping estará dentro dos padrões se for igual ou inferior a 80ms. Essa informação pode ser verificada no Regulamento de Gestão da Qualidade do Serviço de Comunicação Multimídia (RGQ-SCM), aprovado pela Resolução n.º 574, de 28 de outubro de 2011.", isFavorite: false},
        { title: "Diagnóstico Específico - Jogos Online - Servidores Inter/Nacionais", text: "Em geral, servidores nacionais costumam ter menor latência, já que a distância física percorrida pelas informações é menor. Isso se traduz em respostas mais rápidas do jogo às suas ações. Os servidores fora do país do país sofrem com instabilidades devido a questões como congestionamento de rede, problemas na infraestrutura e a distância física. Esses problemas podem causar desconexões, atrasos no jogo (lags) e um aumento na latência (ping).", isFavorite: false},
        { title: "Diagnóstico Específico - Jogos Online - Garantia da Brisanet (Ping)", text: "O ping não depende da velocidade da internet ou do plano contratado, mas sim da geolocalização do cliente e do servidor. Não é possível manter uma média constante; ocorrerão picos de ping elevado. Nesta região, a média de ping é de 50 MS a 120 MS, considerando a localização do servidor em São Paulo ou Rio de Janeiro. Em jogos mobile, as médias de ping não são garantidas, e nenhum provedor pode oferecer ping mais baixo, a menos que você viva em uma das cidades com o servidor do jogo em questão.", isFavorite: false},
        { title: "Diagnóstico Específico - Jogos Online - IP Fixo para Diminuir o Ping", text: "Ter um IP fixo em jogos é benéfico, mantendo seu NAT aberto (Tipo 1) para uma maior compatibilidade na conexão com jogos. A diferença no ping não é grande, pois este está ligado à geolocalização do cliente e do servidor do jogo - quanto mais longe, maior o ping.", isFavorite: false},
        { title: "Diagnóstico Específico - Jogos Online - IP Banido no Jogo/Servidor", text: "A situação é resultado de um jogador que compartilha a mesma faixa de IP recebendo uma punição, impactando sua conexão atual. Para resolver é necessário alterar a faixa de IP ou a aquisição de um IP exclusivo para o seu uso.", isFavorite: false},
        { title: "Diagnóstico Específico - Jogos Online - Alterar Faixa IP Automaticamente", text: "A mudança na faixa de IP ocorrerá automaticamente após alguns dias, durante a atualização do modem e roteador. Se preferir, pode tentar acelerar o processo desligando os equipamentos de internet durante o seu horário de dormir e ligando novamente ao acordar.", isFavorite: false},
        { title: "Diagnóstico Específico - Jogos Online - Alterar Faixa com IP Exclusivo", text: "No caso do IP exclusivo, disponível mediante aquisição junto ao nosso setor Comercial Digital SAC, pelo valor de R$50,00 mensais. Esse IP permanece constante. Se você possui um roteador TP-Link da Brisanet, será necessário removê-lo para permitir que o IP fixo seja gerenciado pelo seu roteador particular, uma vez que o primeiro não é compatível com esse tipo de IP.", isFavorite: false},
        { title: "Diagnóstico Específico - Sites - Verificar OLT PPPoE", text: "Sempre verificar a se a OLT do cliente disca PPPoE na planilha clicando aqui", isFavorite: false},
        { title: "Diagnóstico Específico - Sites - Sondagem", text: "Quais são os sites com problemas? Qual é o problema específico que você está enfrentando? Por exemplo: demorando a carregar, perdas de pacotes, desconexões durante o uso, impossibilidade de login no site. Qual é a média do ping agora? Como era antes do problema? Você tentou acessá-lo por outra rede? Você tentou acessá-lo usando dados móveis?", isFavorite: false},
        { title: "Diagnóstico Específico - Sites - Acesso Remoto?", text: "É possível disponibilizar um computador para que eu possa acessá-lo remotamente e realizar alguns testes?", isFavorite: false},


        // 6. Procedimentos e Explicações Técnicas
        { title: "Procedimentos e Explicações Técnicas - Reiniciar Equipamentos", text: "Vamos tentar um passo simples que resolve muitos casos: por favor, desconecte o modem e o roteador da tomada, aguarde um minuto e conecte-os novamente.", isFavorite: true },
        { title: "Procedimentos e Explicações Técnicas - Aviso de Procedimento Remoto", text: "Vou realizar alguns ajustes na sua conexão que podem causar uma breve interrupção no serviço por alguns minutos. Podemos prosseguir?", isFavorite: false },
        { title: "Procedimentos e Explicações Técnicas - Limpar Cache de Rede (Windows)", text: "Abra o \"Executar\" (tecla Windows + R), digite \"cmd\" e pressione Enter. Na tela preta, digite os seguintes comandos, um de cada vez, pressionando Enter após cada um: ipconfig /release, ipconfig /renew, ipconfig /flushdns.", isFavorite: false },
        { title: "Procedimentos e Explicações Técnicas - Explicação: Instabilidade e Alcance Wi-Fi", text: "A instabilidade pode ser causada por barreiras físicas (paredes, lajes), distância do roteador ou muitos aparelhos conectados. Nossos roteadores têm um alcance padrão de 7 a 12 metros; na rede 5GHz (turbo), esse alcance é menor.", isFavorite: false },
        { title: "Procedimentos e Explicações Técnicas - Explicação: Garantia de Velocidade", text: "A Brisanet garante no mínimo 80% da velocidade de download contratada na rede cabeada. Na rede Wi-Fi, a velocidade pode variar. A velocidade de upload é de 50% do contratado, também com garantia de 80%.", isFavorite: false },
        { title: "Procedimentos e Explicações Técnicas - Explicação: Rede Wi-Fi Unificada (Band Steering)", text: "Seu roteador usa uma tecnologia inteligente que unifica as redes 2.4GHz e 5.8GHz. Ele escolhe automaticamente a melhor frequência para cada dispositivo, garantindo mais estabilidade e desempenho.", isFavorite: false },
        { title: "Procedimentos e Explicações Técnicas - Explicação: Fatores que Afetam a Velocidade (Hardware)", text: "A velocidade pode ser limitada pelo seu equipamento. Cabos de rede antigos (inferiores a CAT 5E) e placas de rede \"Fast Ethernet\" (100Mbps) não suportam planos acima de 100 Mega.", isFavorite: false },
        { title: "Procedimentos e Explicações Técnicas - Explicação: CGNAT, Portas e IP Fixo", text: "A rede da Brisanet usa CGNAT, onde um IP público é compartilhado. Para abrir portas (jogos, câmeras, DVR) ou usar algumas VPNs, é necessário contratar um IP Fixo, que é exclusivo para você e possui um custo mensal.", isFavorite: false },
        { title: "Procedimentos e Explicações Técnicas - Explicação: NAT em Consoles", text: "Existem três tipos de NAT: 1 (Aberta), 2 (Moderada) e 3 (Estrita). O tipo 2 é o mais comum e seguro para redes domésticas. O tipo 3 (Estrita) pode restringir a conexão em alguns jogos.", isFavorite: false },
        { title: "Procedimentos e Explicações Técnicas - Explicação: Ping em Jogos", text: "O ping não depende da velocidade, mas da distância física entre você e o servidor do jogo. Servidores no exterior naturalmente terão um ping mais alto. Não há como garantir um ping baixo constante.", isFavorite: false },
        { title: "Procedimentos e Explicações Técnicas - Alteração de Senha da Rede Wi-Fi", text: "Verifique a nova senha da sua Wi-Fi e informe se conseguiu conectar. Lembre-se, a senha é totalmente minúscula e sem espaços.", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - Rede Unificada - Mensagem Simples", text: "Para otimizar a conexão dos seus aparelhos, seu roteador unifica as redes de 5.8 GHz (turbo) e 2.4 GHz (normal) em uma só. Essa funcionalidade permite que seus dispositivos se conectem automaticamente à frequência ideal, garantindo o melhor alcance e desempenho.", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - Rede Unificada - Mensagem Técnica", text: "Foi instalado um roteador em sua casa que utiliza uma tecnologia inteligente chamada 'Band Steering' para combinar as redes 2.4 GHz (normal) e 5.8 GHz (turbo). Com isso, não é mais necessário se preocupar em escolher manualmente entre essas frequências, pois o roteador faz isso automaticamente para garantir que você sempre desfrute da melhor conexão sem fio possível.", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - Não Tem a Rede Turbo", text: "O aplicativo Brisacliente está passando por uma atualização. Como parte desse processo, a opção de alterar a senha da rede turbo (5.8 GHz) foi removida devido a conflitos que causavam quedas de conexão ao modificar a senha da rede \"turbo\" em dispositivos conectados a uma rede unificada. No entanto, a rede \"turbo\" permanece ativa e unificada. Alterar a senha da rede comum resultará automaticamente na alteração da senha da rede \"turbo\" devido à natureza unificada da rede.", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - Personalizar Rede - Personalizar SSID", text: "Você pode alterar o nome da rede, mas ela seguirá o padrão 'brisa-' e o restante do nome fica à sua escolha. Também não pode ter caracteres especiais. Deseja alterar?", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - Personalizar Rede - Personalizar Senha", text: "Para customizar a senha, você precisa de um roteador próprio. O sistema também pode gerar uma nova senha parecida com a atual.", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - Portas LAN (Físicas) - Modem ONU Fibrehome", text: "O modem FiberHome na sua casa tem apenas a porta lan1 disponível para internet. As outras são destinadas a serviços da Brisanet como TV a cabo e telefonia fixa.", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - Portas LAN (Físicas) - TP-Link", text: "As quatro portas LAN do seu roteador TP-Link estão disponíveis para a internet e são identificadas pela cor laranja.", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - Alcance da Rede Wi-Fi - Sondagem", text: "A que distância, em média, você está enfrentando o problema de conexão?", isFavorite: false}, // Mantido como sondagem
        { title: "Procedimentos e Explicações Técnicas - Alcance da Rede Wi-Fi - Informações", text: "Os roteadores da Brisanet têm um alcance padrão de 7 a 12 metros quadrados. Na rede 2.4Ghz, e na turbo (5Ghz), esse alcance pode ser cerca de 1/3. Para uma melhor cobertura de sinal, é importante instalar o modem em um local sem interferências, como paredes, cerâmicas, gessos, vidros e eletrodomésticos. Para ampliar a cobertura do Wi-Fi, pode ser vantajoso investir em um roteador personal posicionado estrategicamente na residência.", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - WPS", text: "O recurso WPS foi desabilitado no nosso modem/roteador devido a preocupações com a segurança. Para conectar dispositivos por esse recurso, sugerimos adquirir um roteador particular para essa finalidade.", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - Bloqueio Parcial", text: "Identificamos um débito em seu contrato, afetando seu acesso aos serviços. Sua conexão com a internet está limitada. O bloqueio parcial também afeta a disponibilidade de alguns canais em sua TV Brisanet. Se você regularizou o pagamento, solicite a normalização do acesso no aplicativo BrisaCliente.", isFavorite: false},
        { title: "Procedimentos e Explicações Técnicas - Rede Cabeada em Jogos", text: "Escolher usar um cabo de rede (Ethernet) assegura uma transmissão mais ágil e estável dos dados do jogo, comparado ao uso de Wi-Fi. Isso minimiza a ocorrência de atrasos, conhecidos como “lag”, garantindo movimentos e ações mais rápidos e precisos durante o jogo. Além disso, as redes Wi-Fi podem sofrer interferências de diversos fatores, como outros aparelhos eletrônicos na sua casa e obstáculos físicos, como paredes! Optando por uma conexão de rede com fio, você consegue evitar muitos desses problemas e desfrutar a melhor experiência de jogo possível", isFavorite: false},
    ];

    // Remove duplicatas da lista de respostas rápidas mantendo a primeira ocorrência (baseado no título)
    // Isso é feito uma vez na inicialização para limpar a lista base.
    const initialQuickReplies = Array.from(new Map(rawQuickReplies.map(item => [item.title, item])).values());


    // Mapeamento de palavras-chave para categorias (para sugestão de respostas)
    const keywordMap = {
        'Início do Atendimento e Verificação': ['olá', 'apresentação', 'titular', 'dados', 'identidade', 'segurança', 'nome', 'cpf', 'nascimento', 'endereço', 'rg', 'cnh', 'documento'],
        'Cordialidade e Mensagens de Apoio': ['aguarde', 'momento', 'desculpas', 'lamento', 'inconveniente', 'problemas', 'tranquilo', 'urgência', 'prioridade', 'frustração', 'áudio'],
        'Inadimplência e Bloqueio Financeiro': ['débito', 'bloqueio', 'pagamento', 'renegociar', 'fatura', 'conta', 'acesso limitado', 'anatel', 'desconto'],
        'Diagnóstico e Sondagem': ['problema', 'conexão', 'wi-fi', 'cabeada', 'roteador', 'modem', 'luzes', 'los', 'pon', 'fibra', 'fwa', 'antena', 'chuva', 'queda de energia', 'obstruindo', 'sondagem'],
        'Diagnóstico Específico': ['instabilidade', 'lentidão', 'velocidade', 'expectativas', 'teste de velocidade', 'cabo de rede', 'notebook', 'jogos', 'ping', 'perdas de pacotes', 'quedas', 'login', 'servidor', 'plataforma', 'sites', 'vpn', 'protocolo', 'acesso remoto'],
        'Procedimentos e Explicações Técnicas': ['reiniciar', 'desconecte', 'reconfigure', 'ajustes', 'interrupção', 'cmd', 'ipconfig', 'cache', 'instabilidade', 'alcance', 'paredes', 'dispositivos conectados', 'garantia de velocidade', 'band steering', '2.4ghz', '5.8ghz', 'hardware', 'cat 5e', 'fast ethernet', 'cgNAT', 'abrir portas', 'ip fixo', 'nat', 'ping em jogos'],
        'Suporte Específico: BrisaTV': ['brisaTV', 'receptor', 'porta lan2', 'desligue', 'religue', 'atualizar canais', 'controle remoto', 'sinal', 'hdmi', 'canal em manutenção'],
        'Suporte Específico: Telefone Fixo': ['telefone fixo', 'phone1', 'ligações', 'mudo', 'chiando', 'problema físico', 'autenticação da linha', 'histórico de ligações'],
        'Suporte Específico: Aplicativos': ['brisacliente', 'app', 'senha', 'cpf', 'tp-link', 'funções indisponíveis', 'brisaplay', 'brisamusic', 'heroapp', 'netflix', 'skeelo', 'ubook', 'bebanca', 'goread', 'login'],
        'Agendamento e Serviços Avulsos': ['visita técnica', 'agendamento', 'horário', 'cobrança', 'alteração de cômodo', 'taxa', 'troca de equipamento', 'mau uso', 'conecta+'],
        'Falhas Gerais e Manutenções': ['falha na região', 'rompimento de fibra', 'falha na torre', 'instabilidade em sistema interno', 'manutenção', 'serviços externos', 'downdetector'],
        'Encerramento do Atendimento': ['verificação final', 'ajuda', 'avaliação', 'despedida', 'inatividade', 'ausência', 'desrespeito', 'transferência de setor', 'sac', 'financeiro', 'retenção'],
        'Outros Contatos e Informações': ['ouvidoria', 'elogios', 'sugestões', 'denúncias', 'brisamóvel', 'geolocalização', 'ip'],
        'Particularidades Técnicas': ['senha', 'wi-fi', 'rede unificada', 'band steering', 'porta lan', 'modem', 'tp-link', 'alcance', 'interferências', 'wps', 'bloqueio parcial', 'jogos', 'ping', 'nat', 'ip fixo', 'servidor', 'olt', 'acesso remoto', 'boleto'] // Adicionei algumas do final
    };

    let CONFIG = {
        CHECKMARK_THRESHOLD_MS: 70 * 1000, // Tempo para o checkmark (✓) aparecer (1 minuto e 10 segundos)
        TIMER_UPDATE_INTERVAL_MS: 500, // Intervalo de atualização do cronômetro
        MAIN_LOOP_THROTTLE_MS: 1000, // Intervalo de execução do loop principal (otimização)
        INACTIVITY_CLIENT_ALERT_SECONDS: parseInt(localStorage.getItem('inactivityClientAlertSeconds') || '70', 10), // Tempo em segundos para alerta de inatividade do CLIENTE (1 minuto e 10 segundos)
        INACTIVITY_OPERATOR_ALERT_SECONDS: parseInt(localStorage.getItem('inactivityOperatorAlertSeconds') || '30', 10), // NOVO: Tempo em segundos para alerta de inatividade do OPERADOR
        LONG_CONVO_ALERT_MIN: parseInt(localStorage.getItem('longConvoAlertMin') || '15', 10), // Alerta de conversa muito longa (Y minutos totais)
        CONVERSATION_TARGET: parseInt(localStorage.getItem('conversationTarget') || '45', 10), // Meta diária de conversas
        DARK_MODE: localStorage.getItem('darkMode') === 'true',
        QUICK_REPLIES: JSON.parse(localStorage.getItem('quickReplies')) || initialQuickReplies, // Carrega do localStorage ou usa a nova lista
        HOTKEYS: JSON.parse(localStorage.getItem('hotkeys')) || {
            // Atalhos padrão agora com valores como nas suas capturas ou sensíveis defaults
            copyDoc: "Control+Shift+D",
            copyInteraction: "Control+Shift+I", // Padrão
            copyAll: "Control+Shift+A", // Padrão
            copyFullChat: "Control+Shift+F", // Padrão
            openYoda: "Control+Shift+Y", // Padrão
            openReplies: "Control+Shift+R",
            openNotepad: "Control+Shift+N",
            openSettings: "Control+Shift+S",
            openManual: "Control+Shift+M", // Padrão
            toggleMiniDashboard: "Control+Shift+J" // Padrão
        },
        MESSAGES: {
            COPIED_SUCCESS: "Copiado com sucesso!",
            COPY_ERROR: "Erro ao copiar.",
            NOT_FOUND_DOCUMENT: "Nenhum CPF/CNPJ válido encontrado.",
            NOT_FOUND_INTERACTION_DATA: "Dados da interação não identificados ou inacessíveis.",
            ALL_DATA_COPIED: "Todos os dados foram copiados!",
            IFRAME_ACCESS_DENIED: "Acesso bloqueado a conteúdo de iframe por segurança (Cross-Origin). A extração pode estar incompleta.",
            SELECTOR_NOT_FOUND: (selector) => `Elemento PureCloud não encontrado para o seletor: ${Array.isArray(selector) ? selector.join(' ou ') : selector}.`,
            HOTKEY_TRIGGERED: (actionName, combo) => `Atalho '${combo}' para ${actionName} acionado.`,
            ACTION_NOT_FOUND: (action) => `Ação '${action}' não encontrada.`,
            YODA_LINK_NOT_FOUND: "Não foi possível encontrar o link do Yoda. Certifique-se de que o texto 'Chamado Yoda:' e o link 'Clique aqui' estão visíveis na tela do script.",
            FULL_CHAT_COPIED: "Histórico completo da conversa copiado para a área de transferência!",
            HOTKEY_CONFLICT: (combo, action1, action2) => `Conflito de atalho! '${combo}' já está atribuído a '${action1}'. Não pode ser usado para '${action2}'.`
        },
        PURECLOUD_SELECTORS: {
            TOOLBAR: ['div.interaction-controls-primary', 'div[data-qa-id="interaction-controls-primary"]'],
            PARTICIPANT_NAME_BADGE: ['div.interaction-name-wrapper div.participant-name > span', 'p.participant-name', 'span[data-qa-id="participant-name"]'], // Ajuste de seletor
            NATIVE_COPY_BUTTON: ['button[aria-label="Copiar link da interação"]', '.copy-interaction-url-btn', 'button[data-qa-id="copy-interaction-link"]'],
            INTERACTION_ID: ['.interaction-id-display', '[data-automation-id="active-interaction-id"]', 'span[data-qa-id="interaction-id-display"]'],
            SCRIPT_IFRAME: '.interaction-script-container.no-headers.non-call iframe',
            MESSAGING_GADGET_IFRAME: 'iframe[src*="messaging-gadget.html"]',
            INTERACTION_GROUP: ['div.interaction-group', 'div[data-qa-id="interaction-group-list-item"]'],
            SELECTED_INTERACTION_GROUP: ['div.interaction-group.is-selected', 'div[data-qa-id="interaction-group-list-item"].is-selected'],
            NATIVE_CONVERSATION_TIME: ['.duration', 'span[data-bind*="elapsedTimeString"]'],
            LAST_REMOTE_MESSAGE: '.chat-message-group.remote:last-child .message-body',
            CHAT_INPUT_FIELD: ['div[data-qa-id="message-input"] textarea', 'div[data-qa-id="message-input"] > div.message-input-text-area', 'div[data-qa-id="message-input"] .input-box'],
            FULL_CHAT_HISTORY_CONTAINER_IN_IFRAME: [
                '[data-automation-id="message-history"]',
                'div.scroller-wrapper.chat-panel-messages-container',
                'div[data-qa-id="chat-messages-container"]',
                'div[role="log"]'
            ],
            FULL_CHAT_HISTORY_CONTAINER_MAIN_DOC: [
                'div#__gadget_container_1.infrg-1_medium.t-ui-root',
                'div.chat-panel-main',
                'div.chat-messages-container'
            ],
            CHAT_MESSAGE_ELEMENTS: [
                'div[data-automation-id="message-group"]',
                'div.chat-message-group',
                'div.message-group-content',
                'div.message-body'
            ],
            CHAT_STATE_BADGE_CLASS: 'div.chat-state-badge',
            CHAT_STATE_LABEL_WRAP: '.chat-state-badge-label-wrap',
            CONVERSATION_LIST_CONTAINER: ['div.infrg-1_medium.purecloud-grid-layout-grid-cell.interaction-list-column', 'div.interaction-list'],
        },
        POPUP_POSITIONS: JSON.parse(localStorage.getItem('popupPositions') || '{}'),
        MINI_DASHBOARD_VISIBLE: localStorage.getItem('miniDashboardVisible') !== 'false',

        TIMER_COLORS: JSON.parse(localStorage.getItem('timerColors')) || {
            normalText: '#ffffff',
            inactiveText: '#fdd835',
            pausedText: '#f44336',
            normalBg: '#313131',
            selectedNormalText: '#ffffff',
            selectedInactiveText: '#fdd835',
            selectedPausedText: '#f44336',
            selectedNormalBg: '#313131',
            completedBg: '#000000',
            completedText: '#ffffff',
            operatorInactiveText: '#ADD8E6'
        },
        LAST_SCRIPT_VERSION: localStorage.getItem('lastScriptVersion') || '0',
    };

    // Garante que quickReplies tenham os campos padrão
    // Isso é importante para novas respostas adicionadas ou importadas.
    CONFIG.QUICK_REPLIES = CONFIG.QUICK_REPLIES.map(r => ({ ...r, title: r.title || 'Geral', text: r.text || '', isFavorite: r.isFavorite || false }));

    const saveData = () => {
        try {
            localStorage.setItem('quickReplies', JSON.stringify(CONFIG.QUICK_REPLIES));
            localStorage.setItem('conversationTarget', CONFIG.CONVERSATION_TARGET);
            localStorage.setItem('darkMode', CONFIG.DARK_MODE);
            localStorage.setItem('inactivityClientAlertSeconds', CONFIG.INACTIVITY_CLIENT_ALERT_SECONDS);
            localStorage.setItem('inactivityOperatorAlertSeconds', CONFIG.INACTIVITY_OPERATOR_ALERT_SECONDS);
            localStorage.setItem('longConvoAlertMin', CONFIG.LONG_CONVO_ALERT_MIN);
            localStorage.setItem('hotkeys', JSON.stringify(CONFIG.HOTKEYS));
            localStorage.setItem('achievements_v2', JSON.stringify(analyticsManager.getAchievements()));
            localStorage.setItem('popupPositions', JSON.stringify(CONFIG.POPUP_POSITIONS));
            localStorage.setItem('miniDashboardVisible', CONFIG.MINI_DASHBOARD_VISIBLE);
            localStorage.setItem('timerColors', JSON.stringify(CONFIG.TIMER_COLORS));
            localStorage.setItem('lastScriptVersion', '42.53'); // Atualiza a versão salva
            localStorage.setItem('dailyAnalytics_v2_data', JSON.stringify(analyticsManager.getData())); // Salva os dados de analytics aqui também
            log("Configurações salvas no localStorage.");
        } catch (e) {
            if (e.name === 'QuotaExceededError') {
                log("Erro: localStorage cheio ao tentar salvar dados de CONFIG. Limpe o histórico do console/dados de site.", e);
                UI.createNotification("Erro: Espaço de armazenamento cheio. Não foi possível salvar configurações. Limpe os dados do navegador.", 'error', 10000);
            } else {
                log("Erro ao salvar dados de CONFIG no localStorage:", e);
            }
        }
        document.body.classList.toggle('gm-dark-mode', CONFIG.DARK_MODE);
    };

    let completedConversationsCount = 0; // Este será gerenciado pelo analyticsManager
    let dailyDocCopies = 0; // Este será gerenciado pelo analyticsManager
    let dailyHotkeysUsed = new Set(); // Este será gerenciado pelo analyticsManager

    const conversationTimers = new Map();
    const notificationQueue = []; // Fila para notificações empilháveis
    let notificationTimeout;

    // --- FUNÇÕES DE UTILIDADE ---

    const findEl = (selectors, parent = document) => {
        if (!Array.isArray(selectors)) selectors = [selectors];

        for (const selector of selectors) {
            let el = parent.querySelector(selector);
            if (el) return el;

            const tryShadowDom = (node) => {
                if (!node || typeof node.querySelectorAll !== 'function') return null;
                const elementsWithShadow = node.querySelectorAll('*');
                for (let i = 0; i < elementsWithShadow.length; i++) {
                    const shadowRoot = elementsWithShadow[i].shadowRoot;
                    if (shadowRoot) {
                        const foundInShadow = shadowRoot.querySelector(selector);
                        if (foundInShadow) return foundInShadow;
                        const nestedFound = tryShadowDom(shadowRoot);
                        if (nestedFound) return nestedFound;
                    }
                }
                return null;
            };

            el = tryShadowDom(parent);
            if (el) return el;
        }
        return null;
    };

    const throttle = (func, limit) => {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    };

    const formatTime = num => String(num).padStart(2, '0');

    // Funções para lidar com o fuso horário correto (Brasil)
    const getBrazilTime = (date) => {
        // Usa Intl.DateTimeFormat para obter os componentes de data e hora no fuso horário alvo
        // E então constrói uma nova data UTC a partir deles. Isso lida com DST e fusos corretamente.
        const options = {
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', second: '2-digit',
            hour12: false, // Formato 24 horas
            timeZone: 'America/Fortaleza' // Fuso horário de Fortaleza
        };

        try {
            const formatter = new Intl.DateTimeFormat('en-US', options); // Usar en-US para obter um formato parsável facilmente
            const parts = formatter.formatToParts(date);

            const year = parseInt(parts.find(p => p.type === 'year').value);
            const month = parseInt(parts.find(p => p.type === 'month').value) - 1; // Mês é 0-indexed
            const day = parseInt(parts.find(p => p.type === 'day').value);
            const hour = parseInt(parts.find(p => p.type === 'hour').value);
            const minute = parseInt(parts.find(p => p.type === 'minute').value);
            const second = parseInt(parts.find(p => p.type === 'second').value);

            // Reconstruct the date string in ISO format for the target timezone
            const brazilDateString = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}`;
            
            // Create a Date object from the ISO string with the explicit offset.
            // This is crucial for consistent behavior of .getHours() etc.
            return new Date(brazilDateString + '-03:00');  
            
        } catch (e) {
            log("WARN: Erro ao formatar data/hora para fuso horário do Brasil usando Intl.DateTimeFormat. Retornando Date original.", e);
            // Fallback para a data original se Intl.DateTimeFormat falhar
            return date;  
        }
    };


    const getGreeting = () => {
        const hour = getBrazilTime(new Date()).getHours();
        if (hour >= 5 && hour < 12) return 'Bom dia';
        if (hour >= 12 && hour < 18) return 'Boa tarde';
        return 'Boa noite';
    };

    const makeDraggable = (popup, header, popupName) => {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

        // Tenta carregar a posição e o tamanho salvos
        if (CONFIG.POPUP_POSITIONS[popupName]) {
            // Garante que a posição inicial seja definida em px e não em transform para evitar conflitos
            popup.style.top = CONFIG.POPUP_POSITIONS[popupName].top;
            popup.style.left = CONFIG.POPUP_POSITIONS[popupName].left;
            // Restaura as dimensões se salvas
            if (CONFIG.POPUP_POSITIONS[popupName].width) popup.style.width = CONFIG.POPUP_POSITIONS[popupName].width;
            if (CONFIG.POPUP_POSITIONS[popupName].height) popup.style.height = CONFIG.POPUP_POSITIONS[popupName].height;
            
            popup.style.transform = 'none'; // Remove qualquer transformação que possa interferir
            popup.style.margin = '0'; // Garante que margin não interfira
            log(`[makeDraggable] Restaurando posição/tamanho de '${popupName}' para: ${popup.style.left}, ${popup.style.top}, ${popup.style.width}, ${popup.style.height}`);
        } else {
            // Centraliza se não houver posição salva, mas mantém o transform para flexibilidade inicial
            popup.style.top = '50%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.margin = '0';
            log(`[makeDraggable] Nenhuma posição/tamanho salvo para '${popupName}', centralizando.`);
        }

        const saveCurrentPositionAndSize = () => {
            // Converte a posição atual para pixels absolutos se estiver em 'transform'
            let currentTop = popup.style.top;
            let currentLeft = popup.style.left;

            if (popup.style.transform && popup.style.transform !== 'none') {
                const rect = popup.getBoundingClientRect();
                currentTop = rect.top + 'px';
                currentLeft = rect.left + 'px';
            }
            
            CONFIG.POPUP_POSITIONS[popupName] = { 
                top: currentTop, 
                left: currentLeft,
                width: popup.style.width,  // Salva a largura atual
                height: popup.style.height // Salva a altura atual
            };
            saveData();
            log(`[makeDraggable] Posição/tamanho de '${popupName}' salvo: ${CONFIG.POPUP_POSITIONS[popupName].left}, ${CONFIG.POPUP_POSITIONS[popupName].top}, ${CONFIG.POPUP_POSITIONS[popupName].width}, ${CONFIG.POPUP_POSITIONS[popupName].height}`);
        };


        header.onmousedown = e => {
            // Permite cliques em botões dentro do header sem ativar o drag
            if (e.target.closest('.panel-header-btn') || e.target.closest('input') || e.target.closest('textarea') || e.target.closest('button') || e.target.closest('select')) return;
            e.preventDefault();
            
            // Ao iniciar o arrasto, converte para top/left absolutos
            if (popup.style.transform && popup.style.transform !== 'none') {
                const rect = popup.getBoundingClientRect();
                popup.style.top = rect.top + 'px';
                popup.style.left = rect.left + 'px';
                popup.style.transform = 'none';
            }

            pos3 = e.clientX;
            pos4 = e.clientY;
            
            document.onmouseup = () => {
                document.onmouseup = null;
                document.onmousemove = null;
                saveCurrentPositionAndSize(); // Salva a posição ao soltar
            };
            document.onmousemove = ev => {
                ev.preventDefault();
                pos1 = pos3 - ev.clientX;
                pos2 = pos4 - ev.clientY;
                pos3 = ev.clientX;
                pos4 = ev.clientY;
                const newTop = Math.max(0, Math.min(window.innerHeight - popup.offsetHeight, popup.offsetTop - pos2));
                const newLeft = Math.max(0, Math.min(window.innerWidth - popup.offsetWidth, popup.offsetLeft - pos1));
                popup.style.top = newTop + "px";
                popup.style.left = newLeft + "px";
            };
        };

        // Adiciona um observer para salvar a posição e o tamanho ao redimensionar
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                // Verifica se o elemento redimensionado é o próprio popup
                if (entry.target === popup) {
                    saveCurrentPositionAndSize(); // Salva a posição e o tamanho após um redimensionamento
                }
            }
        });
        resizeObserver.observe(popup); // Observa o próprio popup para redimensionamento

        // Lógica de minimização
        const minBtn = header.querySelector('.minimize-btn');
        if (minBtn) {
            minBtn.onclick = (e) => {
                e.stopPropagation();
                const isMinimized = popup.classList.toggle('minimized');
                if (isMinimized) {
                    // Guarda o estado original antes de minimizar
                    popup.dataset.originalTop = popup.style.top;
                    popup.dataset.originalLeft = popup.style.left;
                    popup.dataset.originalWidth = popup.style.width;
                    popup.dataset.originalHeight = popup.style.height;

                    // Ajuste para fixar no canto inferior esquerdo
                    popup.style.left = '20px';
                    popup.style.bottom = '20px'; // Ajustado para não colidir com a borda inferior
                    popup.style.top = 'auto';
                    popup.style.right = 'auto'; // Garante que não haja conflito com o right
                    popup.style.transform = 'none';
                    // Define um tamanho fixo para minimizado
                    popup.style.width = '250px'; // Aumentado para garantir visibilidade dos botões
                    popup.style.height = '42px'; // Altura da header
                    popup.style.overflow = 'hidden'; // Garante que o conteúdo seja cortado
                    log(`[makeDraggable] Mini-dashboard minimizado.`);
                } else { // Restaurar
                    // Restaura o estado original se foi guardado
                    if (popup.dataset.originalTop) popup.style.top = popup.dataset.originalTop;
                    if (popup.dataset.originalLeft) popup.style.left = popup.dataset.originalLeft;
                    if (popup.dataset.originalWidth) popup.style.width = popup.dataset.originalWidth;
                    if (popup.dataset.originalHeight) popup.style.height = popup.dataset.originalHeight;
                    popup.style.bottom = 'auto'; // Remove bottom
                    popup.style.right = 'auto'; // Remove right
                    popup.style.transform = 'none';
                    popup.style.overflow = 'visible'; // Permite overflow novamente
                    log(`[makeDraggable] Mini-dashboard restaurado.`);
                }
                saveCurrentPositionAndSize(); // Salva a nova posição/estado após minimização/restauração
            };
        }
    };

    const analyticsManager = {
        getData() {
            const today = getBrazilTime(new Date()).toLocaleDateString('pt-BR');
            const storedData = JSON.parse(localStorage.getItem('dailyAnalytics_v2_data') || '{}');
            log("[Analytics Manager] Dados carregados do localStorage:", storedData); // DEBUG
            if (storedData.date !== today) {
                log("[Analytics Manager] Data diferente, resetando dados para novo dia."); // DEBUG
                return { date: today, conversations: [], docCopies: 0, hotkeysUsed: [] };
            }
            // Garante que campos existam para dados antigos
            storedData.docCopies = storedData.docCopies || 0;
            storedData.hotkeysUsed = storedData.hotkeysUsed || [];
            storedData.conversations = storedData.conversations.map(conv => ({ 
                ...conv, 
                activeDuration: conv.activeDuration || 0,
                // Garante que timestamp seja um número se por algum motivo foi salvo como string em versões anteriores
                timestamp: typeof conv.timestamp === 'string' ? new Date(conv.timestamp).getTime() : conv.timestamp
            }));
            return storedData;
        },
        saveData(data) {
            try {
                localStorage.setItem('dailyAnalytics_v2_data', JSON.stringify(data));
                log("[Analytics Manager] Dados de analytics salvos:", data); // DEBUG
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    log("Erro: localStorage cheio ao tentar salvar dados de analytics. Limpe o histórico do console/dados de site.", e);
                    UI.createNotification("Erro: Espaço de armazenamento cheio. Não foi possível salvar estatísticas diárias. Limpe os dados do navegador.", 'error', 10000);
                } else {
                    log("Erro ao salvar dados de analytics no localStorage:", e);
                }
            }
        },
        getAchievements() {
            return JSON.parse(localStorage.getItem('achievements_v2') || '{}');
        },
        unlockAchievement(key) {
            const achievements = this.getAchievements();
            if (!achievements[key] || !achievements[key].unlocked) {
                achievements[key] = { unlocked: true, timestamp: Date.now() };
                this.saveAchievements(achievements);
                UI.createNotification(`🏆 Conquista: ${achievementsList[key].title}!`, 'info');
                log(`Conquista desbloqueada: ${achievementsList[key].title}`);
            }
        },
        saveAchievements(achievements) {
            try {
                localStorage.setItem('achievements_v2', JSON.stringify(achievements));
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    log("Erro: localStorage cheio ao tentar salvar conquistas.");
                } else {
                    log("Erro ao salvar conquistas no localStorage:", e);
                }
            }
        },
        logConversation(duration, activeDuration, participantName) {
            const data = this.getData();
            // Sempre armazena timestamp como número (epoch)
            data.conversations.push({ timestamp: Date.now(), duration, activeDuration: activeDuration, participantName: participantName });
            this.saveData(data);
            this.checkAchievements(data.conversations, duration);
            log(`[Analytics Manager] Conversa registrada: ${participantName}. Duração: ${duration}ms, Ativa: ${activeDuration}ms`); // DEBUG
        },
        logDocCopy() {
            const data = this.getData();
            data.docCopies = (data.docCopies || 0) + 1;
            this.saveData(data);
            if (data.docCopies >= 10) this.unlockAchievement('docMaster');
            log(`[Analytics Manager] Documento copiado. Total: ${data.docCopies}`); // DEBUG
        },
        logHotkeyUse(actionName) {
            const data = this.getData();
            if (!data.hotkeysUsed.includes(actionName)) {
                data.hotkeysUsed.push(actionName);
                this.saveData(data);
                log(`[Analytics Manager] Atalho '${actionName}' usado. Atalhos únicos hoje: ${data.hotkeysUsed.length}`); // DEBUG
            }
            // Check if all hotkeys are used based on current CONFIG.HOTKEYS
            const allConfiguredHotkeys = Object.keys(CONFIG.HOTKEYS).filter(key => CONFIG.HOTKEYS[key]); // Filter out empty hotkeys
            if (data.hotkeysUsed.length >= allConfiguredHotkeys.length && allConfiguredHotkeys.every(key => data.hotkeysUsed.includes(key))) {
                this.unlockAchievement('hotkeyMaster');
            }
        },
        checkAchievements(conversations, duration) {
            // Conta apenas conversas "completas" para as conquistas baseadas em contagem
            const completedConvos = conversations.filter(c => c.duration >= CONFIG.CHECKMARK_THRESHOLD_MS);

            if (completedConvos.length >= 5) this.unlockAchievement('firstFive');
            // 'Speed Demon' verifica se alguma conversa individual foi rápida
            if (duration < 60000) this.unlockAchievement('speedDemon'); // Logged per conversation, checks if a single conversation was fast
            // 'Target Hit' verifica a contagem de conversas completas vs. a meta
            if (completedConvos.length >= CONFIG.CONVERSATION_TARGET) this.unlockAchievement('targetHit');
        },
        calculateStats() {
            const data = this.getData();
            const conversations = data.conversations;
            log("[Analytics Manager] Conversas para calcular stats (bruto):", conversations); // DEBUG
            if (conversations.length === 0) {
                return { count: 0, aht: '00:00', tme: '00:00', perHour: {}, first: 'N/A', last: 'N/A', docCopies: data.docCopies, hotkeysUsed: data.hotkeysUsed.length, allConversations: conversations };
            }

            // Filtrar apenas conversas "completas" para a contagem principal e TMA/TME
            const completedConvos = conversations.filter(c => c.duration >= CONFIG.CHECKMARK_THRESHOLD_MS);
            const totalDuration = completedConvos.reduce((sum, conv) => sum + conv.duration, 0);
            const totalActiveDuration = completedConvos.reduce((sum, conv) => sum + (conv.activeDuration || 0), 0);
            
            const ahtSeconds = completedConvos.length > 0 ? Math.floor((totalDuration / completedConvos.length) / 1000) : 0;
            const tmeSeconds = completedConvos.length > 0 ? Math.floor((totalActiveDuration / completedConvos.length) / 1000) : 0;

            const aht = `${formatTime(Math.floor(ahtSeconds / 60))}:${formatTime(ahtSeconds % 60)}`;
            const tme = `${formatTime(Math.floor(tmeSeconds / 60))}:${formatTime(tmeSeconds % 60)}`;

            // Para o gráfico por hora, usar as conversas completas
            const perHour = {};
            for (let hour = 0; hour < 24; hour++) { perHour[hour] = 0; } // Inicializa todas as horas com 0
            completedConvos.forEach(conv => { 
                const convDate = getBrazilTime(new Date(conv.timestamp)); // Converte para Date object no fuso do Brasil
                const hour = convDate.getHours(); // Extrai a hora do dia
                perHour[hour] = (perHour[hour] || 0) + 1; // Incrementa a contagem para aquela hora
            });
            log("[Analytics Manager] Conversas por Hora (perHour calculado):", perHour); // DEBUG

            // Garantir que first e last também usem o getBrazilTime para formatação
            // Ordena as conversas para garantir que a primeira e última sejam as corretas
            const sortedByTimestamp = [...completedConvos].sort((a, b) => a.timestamp - b.timestamp);
            
            const first = sortedByTimestamp.length > 0 ? getBrazilTime(new Date(sortedByTimestamp[0].timestamp)).toLocaleTimeString('pt-BR', {hour: '2-digit', minute: '2-digit', second: '2-digit'}) : 'N/A';
            const last = sortedByTimestamp.length > 0 ? getBrazilTime(new Date(sortedByTimestamp[sortedByTimestamp.length - 1].timestamp)).toLocaleTimeString('pt-BR', {hour: '2-digit', minute: '2-digit', second: '2-digit'}) : 'N/A';
            
            log("[Analytics Manager] Primeira conversa formatada:", first, "Última conversa formatada:", last); // DEBUG
            return { count: completedConvos.length, aht, tme, perHour, first, last, docCopies: data.docCopies, hotkeysUsed: data.hotkeysUsed.length, allConversations: conversations };
        },
        clearAllData() {
            localStorage.removeItem('dailyAnalytics_v2_data');
            localStorage.removeItem('achievements_v2');
            // Zera também os contadores da toolbar no localStorage para garantir consistência
            localStorage.removeItem('gmCompletedConversationsCount'); // Legacy key
            localStorage.removeItem('gmDailyDocCopies'); // Legacy key
            localStorage.removeItem('gmDailyHotkeysUsed'); // Legacy key
            localStorage.removeItem('gmLastActivityDate'); // Legacy key

            log("[Analytics Manager] Todos os dados de atendimentos e conquistas foram limpos."); // DEBUG
            // Resetar variáveis globais in-memory para refletir o estado limpo imediatamente
            completedConversationsCount = 0;
            dailyDocCopies = 0;
            dailyHotkeysUsed = new Set();
            // Recalcular stats para atualizar o UI do analytics manager
            this.calculateStats(); // Isso vai carregar o estado limpo do localStorage
        }
    };
    // Expor analyticsManager globalmente para evitar erros de referência
    window.analyticsManager = analyticsManager;


    const documentExtractor = {
        validateCPF: (cpf) => { cpf = (cpf || '').replace(/\D/g, ''); if (cpf.length !== 11 || /^(\d)\1+$/.test(cpf)) return false; let sum = 0; for (let i = 0; i < 9; i++) sum += parseInt(cpf.charAt(i)) * (10 - i); let check = 11 - (sum % 11); if (check >= 10) check = 0; if (check !== parseInt(cpf.charAt(9))) return false; sum = 0; for (let i = 0; i < 10; i++) sum += parseInt(cpf.charAt(i)) * (11 - i); check = 11 - (sum % 11); if (check >= 10) check = 0; return check === parseInt(cpf.charAt(10)); },
        validateCNPJ: (cnpj) => { cnpj = (cnpj || '').replace(/\D/g, ''); if (cnpj.length !== 14 || /^(\d)\1+$/.test(cnpj)) return false; let size = cnpj.length - 2; let numbers = cnpj.substring(0,size); const digits = cnpj.substring(size); let sum = 0; let pos = size - 7; for (let i = size; i >= 1; i--) { sum += numbers.charAt(size - i) * pos--; if (pos < 2) pos = 9; } let result = sum % 11 < 2 ? 0 : 11 - sum % 11; if (result != digits.charAt(0)) return false; size = size + 1; numbers = cnpj.substring(0,size); sum = 0; pos = size - 7; for (let i = size; i >= 1; i--) { sum += numbers.charAt(size - i) * pos--; if (pos < 2) pos = 9; } result = sum % 11 < 2 ? 0 : 11 - sum % 11; return result == digits.charAt(1); },
        async getContextText() {
            let text = '';
            const selectedConv = findEl(CONFIG.PURECLOUD_SELECTORS.SELECTED_INTERACTION_GROUP);
            if(selectedConv) text += selectedConv.innerText;
            try {
                const scriptIframe = findEl(CONFIG.PURECLOUD_SELECTORS.SCRIPT_IFRAME);
                if (scriptIframe && scriptIframe.contentDocument) text += ' ' + scriptIframe.contentDocument.body.innerText;
                const msgIframe = findEl(CONFIG.PURECLOUD_SELECTORS.MESSAGING_GADGET_IFRAME);
                if (msgIframe && msgIframe.contentDocument) text += ' ' + msgIframe.contentDocument.body.innerText;
            } catch (e) {
                if (e.name === 'SecurityError') {
                    UI.createNotification(CONFIG.MESSAGES.IFRAME_ACCESS_DENIED, 'warn');
                    log("Erro de segurança ao acessar iframe:", e);
                } else {
                    UI.createNotification("Não foi possível acessar dados de um iframe.", 'error');
                    log("Erro ao acessar iframe:", e);
                }
            }
            return text;
        },
        extractDocuments(text) {
            const docs = new Set();
            const cpfRegex = /\b(\d{3}\.?\d{3}\.?\d{3}-?\d{2})\b/g;
            const cnpjRegex = /\b(\d{2}\.?\d{3}\.?\d{3}\/?\d{4}-?\d{2})\b/g;

            Array.from(text.matchAll(cpfRegex)).map(m => m[1]).forEach(m => { const c = m.replace(/\D/g,''); if(this.validateCPF(c)) docs.add(c); });
            Array.from(text.matchAll(cnpjRegex)).map(m => m[1]).forEach(m => { const c = m.replace(/\D/g,''); if(this.validateCNPJ(c)) docs.add(c); });
            return Array.from(docs);
        },
        getParticipantName: (parentEl = document) => {
            const el = findEl(CONFIG.PURECLOUD_SELECTORS.PARTICIPANT_NAME_BADGE, parentEl);
            return el?.textContent.trim();
        },
        getInteractionId: (parentEl = document) => {
            const el = findEl(CONFIG.PURECLOUD_SELECTORS.INTERACTION_ID, parentEl);
            return el?.textContent.trim().replace(/#/g, '');
        },
    };

    // --- Descrições das funcionalidades para o Manual ---
    const featureDescriptions = {
        copyAll: { title: "Copiar Dados", description: "Copia para a área de transferência o nome do cliente, protocolo da interação e quaisquer CPFs/CNPJs encontrados no contexto da conversa. Útil para documentação rápida.", hotkey: "Control+Shift+A" },
        copyDoc: { title: "Copiar Documento", description: "Detecta e copia CPFs ou CNPJs do texto da conversa. Se múltiplos documentos forem encontrados, um pop-up permite escolher qual copiar. Ideal para validação de dados.", hotkey: "Control+Shift+D" },
        copyInteraction: { title: "Copiar Interação", description: "Copia o nome do cliente e o link direto para a interação no PureCloud. Facilita o compartilhamento ou referência da conversa.", hotkey: "Control+Shift+I" },
        copyFullChat: { title: "Conversa Completa", description: "Copia todo o histórico de mensagens da conversa atual para a área de transferência. Útil para registrar o chat em sistemas externos ou para análise.", hotkey: "Control+Shift+F" },
        openReplies: { title: "Respostas Rápidas", description: "Abre um painel com respostas predefinidas. Possui busca, categorização automática por palavras-chave da última mensagem do cliente e suporte a favoritos. Permite preencher automaticamente dados como nome do cliente e protocolo.", hotkey: "Control+Shift+R" },
        openYoda: { title: "Abrir Dashboard Yoda", description: "Localiza o link 'Clique aqui' adjacente ao texto 'Chamado Yoda:' na tela do script (painel direito), intercepta o URL dinâmico e abre-o em uma nova aba. Ideal para casos em que o link do Yoda muda frequentemente.", hotkey: "Control+Shift+Y" },
        openNotepad: { title: "Bloco de Notas", description: "Abre um bloco de notas exclusivo para a conversa atual. As anotações são salvas automaticamente e persistem para aquela interação.", hotkey: "Control+Shift+N" },
        openSettings: { title: "Configurações", description: "Abre o painel de configurações do script, onde você pode gerenciar respostas rápidas, definir metas de conversas, ativar o modo escuro, ajustar alertas, visualizar estatísticas e gerenciar atalhos de teclado. Inclui opções de backup e restauração.", hotkey: "Control+Shift+S" },
        openManual: { title: "Manual do Script", description: "Exibe este manual com descrições detalhadas de todas as funcionalidades e atalhos de teclado do script.", hotkey: "Control+Shift+M" },
        conversationCounter: { title: "Contador de Conversas (Atendidas)", description: "Exibe o número de conversas completas (duração > 1min 10s) hoje em relação à sua sua meta diária. Inclui um botão para ajustar a contagem manualmente no mini-dashboard.", hotkey: "N/A" }, // Atualizado
        conversationTimers: { title: "Timers de Conversa", description: "Adiciona um timer individual a cada conversa na lista lateral, mostrando o tempo decorrido. O timer pausa automaticamente quando a conversa não está selecionada. Alerta visualmente sobre inatividade do cliente e conversas muito longas." },
        achievements: { title: "Sistema de Conquistas", description: "Gere conquistas baseadas no seu desempenho diário (ex: completar 5 conversas, copiar 10 documentos). Visualize suas conquistas na aba de Analytics das configurações." },
        miniDashboard: { title: "Mini-Dashboard de Produtividade", description: "Um pequeno painel flutuante que exibe as Conversas Atendidas, TMA e TME do dia de forma resumida, atualizando em tempo real. Posição é salva automaticamente. Possui botão para ajuste manual da contagem de atendimentos. Pode ser ocultado via atalho Control+Shift+J.", hotkey: "Control+Shift+J" }, // Atualizado
        operatorInactivityAlert: { title: "Alerta de Inatividade do Operador", description: "Monitora sua própria inatividade no campo de chat ativo (tempo configurável) e muda a cor do cronômetro para indicar que você não digitou nada por um tempo. Cor padrão: Roxo." },
        exportAnalytics: { title: "Exportar Dados de Atendimentos", description: "Permite exportar o histórico detalhado de atendimentos (TMA, TME, cliente, hora) para um arquivo JSON." },
        chatLinkHighlight: { title: "Destaque de Links/IDs no Chat", description: "Detecta URLs e IDs de interação no histórico de chat e os torna clicáveis ou destacados para facilitar a interação." }
    };

    const achievementsList = {
        firstFive: { title: "Primeiros Passos", description: "Complete 5 conversas em um dia." },
        speedDemon: { title: "Demônio da Velocidade", description: "Complete uma conversa em menos de 1 minuto." },
        docMaster: { title: "Mestre dos Documentos", description: "Copie 10 documentos (CPFs/CNPJs) em um dia." },
        hotkeyMaster: { title: "Mestre dos Atalhos", description: "Use todos os atalhos de teclado disponíveis em um dia." },
        targetHit: { title: "Meta Atendida", description: `Atinja sua meta diária de conversas (${CONFIG.CONVERSATION_TARGET}).` },
    };

    const UI = {
        _notificationCount: 0,
        createNotification(message, type = 'info', duration = 3000) {
            let notificationContainer = document.getElementById('purecloud-script-notification-container');
            if (!notificationContainer) {
                notificationContainer = document.createElement('div');
                notificationContainer.id = 'purecloud-script-notification-container';
                document.body.appendChild(notificationContainer);
            }

            const n = document.createElement("div");
            n.textContent = message;
            n.className = `purecloud-script-notification purecloud-script-notification-${type}`;
            notificationContainer.prepend(n); // Adiciona no topo da lista (empilha para baixo)

            const visibleNotifications = document.querySelectorAll('#purecloud-script-notification-container .purecloud-script-notification');
            if (visibleNotifications.length > 5) {
                visibleNotifications[visibleNotifications.length - 1].remove();
            }

            setTimeout(() => {
                n.style.opacity = '0';
                n.style.transform = 'translateX(100%)';
                setTimeout(() => n.remove(), 300);
            }, duration);
        },
        createDocumentPopup(docs) {
            document.querySelector('.purecloud-script-doc-popup')?.remove();
            const p = document.createElement("div"); p.className = 'purecloud-script-doc-popup purecloud-script-popup';
            p.innerHTML = `
                <div class="panel-header">
                    <h3>Múltiplos Documentos</h3>
                    <div class="panel-header-buttons">
                        <button class="panel-header-btn purecloud-script-popup-close-btn" title="Fechar">X</button>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="items-container"></div>
                </div>
            `;
            const i = p.querySelector('.items-container');
            docs.forEach(doc => {
                const item = document.createElement('div'); item.className = 'item';
                item.textContent = doc.length === 11 ? doc.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4') : doc.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
                item.onclick = async () => {
                    if (await copyTextToClipboard(doc)) {
                        UI.createNotification(`${type} copiado com sucesso!`, 'success');
                        analyticsManager.logDocCopy();
                        p.remove();
                    } else {
                        UI.createNotification(CONFIG.MESSAGES.COPY_ERROR, 'error');
                    }
                };
                i.appendChild(item);
            });
            p.querySelector('.purecloud-script-popup-close-btn').onclick = () => p.remove();
            document.body.appendChild(p);
            makeDraggable(p, p.querySelector('.panel-header'), 'documentPopup');
        },
        renderBarChart(container, perHourData) {
            container.innerHTML = '';
            if (Object.keys(perHourData).length === 0) {
                container.innerHTML = '<div class="chart-placeholder">Nenhuma conversa para exibir gráfico.</div>';
                return;
            }

            const maxCount = Math.max(...Object.values(perHourData));
            const chartWrapper = document.createElement('div');
            chartWrapper.className = 'chart-bars-wrapper';

            for (let hour = 0; hour < 24; hour++) {
                const count = perHourData[hour] || 0;
                // Calcula a altura da barra proporcionalmente, com uma altura mínima para visibilidade
                const height = (count / (maxCount || 1)) * 90; // 90% da altura do container, deixa espaço para labels
                const barWrapper = document.createElement('div');
                barWrapper.className = 'chart-bar-wrapper';
                barWrapper.title = `${count} conversas às ${String(hour).padStart(2, '0')}h`;
                // Ajusta a posição da barra para que ela comece na parte inferior
                barWrapper.style.height = '100%';
                barWrapper.style.position = 'relative'; // Para posicionar as labels/contagem
                barWrapper.innerHTML = `
                    <div class="chart-bar" style="height: ${height}%; position: absolute; bottom: 0; width: 80%;">
                        <span class="bar-count">${count > 0 ? count : ''}</span>
                    </div>
                    <span class="bar-label">${String(hour).padStart(2, '0')}h</span>
                `;
                chartWrapper.appendChild(barWrapper);
            }
            container.innerHTML = `<div class="chart-scroll-container">${chartWrapper.outerHTML}</div>`;
        },
        createSettingsPanel() {
            // Remove qualquer instância anterior do painel de configurações para garantir que uma nova seja criada
            document.querySelector('.purecloud-script-settings-panel')?.remove();
            
            const panel = document.createElement('div');
            panel.className = 'purecloud-script-settings-panel purecloud-script-popup';
            panel.innerHTML = `
                <div class="panel-header">
                    <h2>Configurações do Script PureCloud</h2>
                    <div class="panel-header-buttons">
                        <button class="panel-header-btn minimize-btn" title="Minimizar">_</button>
                        <button class="panel-header-btn purecloud-script-popup-close-btn" id="closeSettingsPanelBtn" title="Fechar">X</button>
                    </div>
                </div>
                <div class="purecloud-script-tabs">
                    <button class="purecloud-script-tab-button active" data-tab="replies">Respostas</button>
                    <button class="purecloud-script-tab-button" data-tab="general">Geral</button>
                    <button class="purecloud-script-tab-button" data-tab="analytics">Analytics</button>
                    <button class="purecloud-script-tab-button" data-tab="details">Atendimentos</button>
                    <button class="purecloud-script-tab-button" data-tab="hotkeys">Atalhos</button>
                    <button class="purecloud-script-tab-button" data-tab="colors">Cores</button>
                    <button class="purecloud-script-tab-button" data-tab="backup">Backup</button>
                    <button class="purecloud-script-tab-button" data-tab="manual">Manual</button>
                </div>
                <div class="panel-content">
                    <div class="purecloud-script-tab-content active" data-tab-content="replies"></div>
                    <div class="purecloud-script-tab-content" data-tab-content="general"></div>
                    <div class="purecloud-script-tab-content" data-tab-content="analytics"></div>
                    <div class="purecloud-script-tab-content" data-tab-content="details"></div>
                    <div class="purecloud-script-tab-content" data-tab-content="hotkeys"></div>
                    <div class="purecloud-script-tab-content" data-tab-content="colors"></div>
                    <div class="purecloud-script-tab-content" data-tab-content="backup"></div>
                    <div class="purecloud-script-tab-content" data-tab-content="manual"></div>
                </div>
                <div class="panel-footer">
                    <button id="save-settings-btn" class="purecloud-script-button">Salvar e Fechar</button>
                </div>
            `;
            document.body.appendChild(panel);
            makeDraggable(panel, panel.querySelector('.panel-header'), 'settingsPanel');

            // --- FIX: Botão de fechar configurações ---
            panel.querySelector('#closeSettingsPanelBtn').onclick = () => panel.remove();


            const switchTab = (tabId) => {
                panel.querySelectorAll('.purecloud-script-tab-button').forEach(btn => btn.classList.remove('active'));
                panel.querySelectorAll('.purecloud-script-tab-content').forEach(content => content.classList.remove('active'));

                const targetTabBtn = panel.querySelector(`.purecloud-script-tab-button[data-tab="${tabId}"]`);
                const targetTabContent = panel.querySelector(`[data-tab-content="${tabId}"]`);

                if (targetTabBtn) targetTabBtn.classList.add('active');
                if (targetTabContent) targetTabContent.classList.add('active');

                // Renderiza o conteúdo da aba quando ela é ativada
                if (tabId === 'replies') {
                    renderReplies();
                } else if (tabId === 'general') {
                    // Conteúdo general é estático, mas garanta valores corretos
                    panel.querySelector('#conversation-target').value = CONFIG.CONVERSATION_TARGET;
                    panel.querySelector('#dark-mode-toggle').checked = CONFIG.DARK_MODE;
                    panel.querySelector('#inactivity-client-alert-seconds').value = CONFIG.INACTIVITY_CLIENT_ALERT_SECONDS;
                    panel.querySelector('#inactivity-operator-alert-seconds').value = CONFIG.INACTIVITY_OPERATOR_ALERT_SECONDS;
                    panel.querySelector('#long-convo-alert-min').value = CONFIG.LONG_CONVO_ALERT_MIN;
                }
                else if (tabId === 'analytics') {
                    UI.renderAnalyticsContent(targetTabContent);
                } else if (tabId === 'details') {
                    UI.renderDetailsContent(targetTabContent);
                } else if (tabId === 'colors') {
                    UI.renderColorsContent(targetTabContent);
                } else if (tabId === 'hotkeys') {
                    UI.renderHotkeysContent(targetTabContent);
                } else if (tabId === 'backup') {
                    UI.renderBackupContent(targetTabContent);
                } else if (tabId === 'manual') {
                    UI.renderManualContent(targetTabContent);
                }
            };
            panel.querySelectorAll('.purecloud-script-tab-button').forEach(btn => {
                btn.onclick = () => switchTab(btn.dataset.tab);
            });

            const renderReplies = () => {
                const repliesTab = panel.querySelector('[data-tab-content="replies"]');
                let repliesHtml = CONFIG.QUICK_REPLIES.map((reply, index) => `
                    <div class="reply-item" data-index="${index}">
                        <input type="checkbox" class="favorite-toggle" title="Marcar como favorito" ${reply.isFavorite ? 'checked' : ''}>
                        <input type="text" value="${reply.title}" class="reply-title" placeholder="Categoria - Título">
                        <textarea class="reply-text">${reply.text}</textarea>
                        <button class="remove-reply-btn" title="Remover">🗑️</button>
                        <button class="purecloud-script-button button-secondary copy-reply-settings" data-text="${encodeURIComponent(reply.text)}" style="padding: 5px 10px;">Copiar</button>
                    </div>`).join('');
                repliesTab.innerHTML = `
                    <h4>Minhas Respostas Pessoais</h4>
                    <div class="reply-controls">
                        <button id="add-reply-btn" class="purecloud-script-button">Adicionar</button>
                        <button id="restore-replies-btn" class="purecloud-script-button button-danger">Restaurar Padrão</button>
                    </div>
                    <div id="quick-replies-list">${repliesHtml}</div>`;

                repliesTab.querySelectorAll('.copy-reply-settings').forEach(button => {
                    button.addEventListener('click', (e) => {
                        const textToCopy = decodeURIComponent(e.target.dataset.text);
                        navigator.clipboard.writeText(textToCopy).then(() => {
                            log("Resposta rápida copiada das configurações!");
                            const originalText = button.textContent;
                            button.textContent = "Copiado!";
                            setTimeout(() => button.textContent = originalText, 1500);
                        }).catch(err => {
                            console.error('Erro ao copiar texto:', err);
                        });
                    });
                });
            };
            // Chama renderReplies para a aba inicial de Respostas
            renderReplies();  

            // Conteúdo da aba Geral (Estático, com inputs e botões)
            const generalTab = panel.querySelector('[data-tab-content="general"]');
            generalTab.innerHTML = `
                <div class="settings-group">
                    <label for="conversation-target">Meta de Conversas:</label>
                    <input type="number" id="conversation-target" value="${CONFIG.CONVERSATION_TARGET}">
                </div>
                <div class="settings-group">
                    <label>Modo Escuro:</label>
                    <label class="switch">
                        <input type="checkbox" id="dark-mode-toggle" ${CONFIG.DARK_MODE ? 'checked' : ''}>
                        <span class="slider round"></span>
                    </label>
                </div>
                <div class="settings-group">
                    <label for="inactivity-client-alert-seconds">Alerta de Inatividade do CLIENTE (segundos):</label>
                    <input type="number" id="inactivity-client-alert-seconds" value="${CONFIG.INACTIVITY_CLIENT_ALERT_SECONDS}">
                </div>
                <div class="settings-group">
                    <label for="inactivity-operator-alert-seconds">Alerta de Inatividade do OPERADOR (segundos):</label>
                    <input type="number" id="inactivity-operator-alert-seconds" value="${CONFIG.INACTIVITY_OPERATOR_ALERT_SECONDS}">
                </div>
                <div class="settings-group">
                    <label for="long-convo-alert-min">Alerta de Conversa Longa (minutos):</label>
                    <input type="number" id="long-convo-alert-min" value="${CONFIG.LONG_CONVO_ALERT_MIN}">
                </div>
                <div class="settings-group">
                    <label>Contador Geral:</label>
                    <button id="reset-counter-btn" class="purecloud-script-button button-danger">Resetar Contadores Diários</button>
                </div>`;
            
            generalTab.querySelectorAll('input[type="number"]').forEach(input => {
                input.addEventListener('input', () => {
                    const value = parseInt(input.value, 10);
                    if (isNaN(value) || value < 0) {
                        input.classList.add('invalid-input');
                        input.title = 'Por favor, insira um número positivo.';
                    } else {
                        input.classList.remove('invalid-input');
                        input.title = '';
                    }
                });
            });

            // Conteúdo da aba Analytics (será preenchido por renderAnalyticsContent)
            panel.querySelector('[data-tab-content="analytics"]').innerHTML = `
                <div id="analytics-content-main">
                    <p>Clique no botão para carregar os dados.</p>
                    <button id="load-stats-btn" class="purecloud-script-button">Carregar Estatísticas do Dia</button>
                </div>
                <div id="achievements-container-main">
                    <h4>Conquistas</h4>
                    <div class="achievements-grid"></div>
                </div>
                <div class="analytics-chart-container-main"></div>`;
            
            const loadStatsBtn = panel.querySelector('#load-stats-btn');
            if (loadStatsBtn) {
                loadStatsBtn.onclick = () => {
                    UI.renderAnalyticsContent(panel.querySelector('[data-tab-content="analytics"]'));
                };
            }

            // Conteúdo da aba Atendimentos (será preenchido por renderDetailsContent)
            panel.querySelector('[data-tab-content="details"]').innerHTML = `<h4>Detalhes dos Atendimentos</h4><div id="details-list"></div><button id="export-details-btn" class="purecloud-script-button">Exportar Detalhes (JSON)</button>`;
            
            const exportDetailsBtn = panel.querySelector('#export-details-btn');
            if (exportDetailsBtn) {
                exportDetailsBtn.onclick = () => {
                    const dataToExport = analyticsManager.getData().conversations;
                    const filename = `purecloud_script_attendances_${getBrazilTime(new Date()).toISOString().split('T')[0]}.json`;
                    const blob = new Blob([JSON.stringify(dataToExport, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    UI.createNotification("Dados de atendimentos exportados com sucesso!", "success");
                };
            }

            // --- FIX: Hotkeys content generation and event listeners ---
            UI.renderHotkeysContent = (container) => {
                const hotkeyActions = {
                    copyDoc: "Copiar Documento",
                    copyInteraction: "Copiar Interação",
                    copyAll: "Copiar Dados",
                    copyFullChat: "Conversa Completa",
                    openYoda: "Abrir Yoda (Link Dinâmico)",
                    openReplies: "Abrir Respostas Rápidas",
                    openNotepad: "Abrir Bloco de Notas",
                    openSettings: "Abrir Configurações",
                    openManual: "Abrir Manual",
                    toggleMiniDashboard: "Alternar Mini-Dashboard"
                };
                container.innerHTML = Object.entries(hotkeyActions).map(([key, label]) => `
                    <div class="settings-group hotkey-group">
                        <label>${label}:</label>
                        <input type="text" class="hotkey-input" data-action="${key}" value="${CONFIG.HOTKEYS[key] || ''}" placeholder="Clique e pressione as teclas" readonly>
                        <button class="clear-hotkey-btn" title="Limpar Atalho">X</button>
                    </div>
                `).join('');
                container.addEventListener('keydown', e => {
                    if (e.target.classList.contains('hotkey-input')) {
                        e.preventDefault();
                        const combo = [];
                        if (e.ctrlKey) combo.push('Control');
                        if (e.shiftKey) combo.push('Shift');
                        if (e.altKey) combo.push('Alt');
                        // Garante que apenas uma tecla não-modificadora seja capturada
                        if (!['Control', 'Shift', 'Alt', 'Meta'].includes(e.key)) {
                            combo.push(e.key === ' ' ? 'Space' : (e.key.length === 1 ? e.key.toUpperCase() : e.key));
                        }
                        e.target.value = combo.join('+');
                    }
                });
                container.addEventListener('click', e => {
                    if (e.target.classList.contains('clear-hotkey-btn')) {
                        const input = e.target.previousElementSibling;
                        if (input && input.classList.contains('hotkey-input')) {
                            input.value = ''; // Limpa o valor do input
                        }
                    }
                });
            };
            UI.renderHotkeysContent(panel.querySelector('[data-tab-content="hotkeys"]'));

            // --- FIX: Colors content generation and event listeners ---
            UI.renderColorsContent = (container) => {
                container.innerHTML = `
                    <div class="settings-group">
                        <label for="timer-color-normal">Cronômetro Normal (Texto):</label>
                        <input type="color" id="timer-color-normal" value="${CONFIG.TIMER_COLORS.normalText}">
                    </div>
                    <div class="settings-group">
                        <label for="timer-color-inactive">Inatividade Cliente (Texto):</label>
                        <input type="color" id="timer-color-inactive" value="${CONFIG.TIMER_COLORS.inactiveText}">
                    </div>
                    <div class="settings-group">
                        <label for="timer-color-paused">Pausado (Texto):</label>
                        <input type="color" id="timer-color-paused" value="${CONFIG.TIMER_COLORS.pausedText}">
                    </div>
                    <div class="settings-group">
                        <label for="timer-color-operator-inactive">Inatividade Operador (Texto):</label>
                        <input type="color" id="timer-color-operator-inactive" value="${CONFIG.TIMER_COLORS.operatorInactiveText}">
                    </div>
                    <div class="settings-group">
                        <label for="timer-color-normal-bg">Fundo Cronômetro (Normal/Pausado/Inativo):</label>
                        <input type="color" id="timer-color-normal-bg" value="${CONFIG.TIMER_COLORS.normalBg}">
                    </div>
                    <div class="settings-group">
                        <label for="timer-color-completed-bg">Concluído (Fundo Check):</label>
                        <input type="color" id="timer-color-completed-bg" value="${CONFIG.TIMER_COLORS.completedBg}">
                    </div>
                    <div class="settings-group">
                        <label for="timer-color-completed-text">Concluído (Texto Check):</label>
                        <input type="color" id="timer-color-completed-text" value="${CONFIG.TIMER_COLORS.completedText}">
                    </div>
                    <div class="settings-group">
                        <button id="reset-colors-btn" class="purecloud-script-button button-danger">Resetar Cores Padrão</button>
                    </div>
                `;
                panel.querySelector('#reset-colors-btn').onclick = () => {
                    if (confirm("Tem certeza que deseja resetar todas as cores do cronômetro para o padrão?")) {
                        CONFIG.TIMER_COLORS = {
                            normalText: '#ffffff',
                            inactiveText: '#fdd835',
                            pausedText: '#f44336',
                            normalBg: '#313131',
                            selectedNormalText: '#ffffff',
                            selectedInactiveText: '#fdd835',
                            selectedPausedText: '#f44336',
                            selectedNormalBg: '#313131',
                            completedBg: '#218838', // Verde original para checkmark
                            completedText: '#ffffff', // Branco original para checkmark
                            operatorInactiveText: '#82b1ff' // Azul Claro original
                        };
                        UI.renderColorsContent(container); // Re-renderiza para mostrar as cores padrão
                        UI.createNotification("Cores padrão restauradas. Clique em Salvar para aplicar.", "info");
                    }
                };
            };
            UI.renderColorsContent(panel.querySelector('[data-tab-content="colors"]'));


            // --- FIX: Backup content generation and event listeners ---
            UI.renderBackupContent = (container) => {
                container.innerHTML = `
                    <div class="settings-group">
                        <h4>Backup e Restauração</h4>
                        <p>Salve suas configurações e respostas em um arquivo ou restaure de um backup anterior.</p>
                        <div class="backup-buttons">
                            <button id="export-btn" class="purecloud-script-button">Exportar</button>
                            <input type="file" id="import-file-input" accept=".json" style="display: none;">
                            <button id="import-btn" class="purecloud-script-button">Importar</button>
                        </div>
                    </div>`;
                // FIX: Attach event listeners to the new buttons
                panel.querySelector('#export-btn').onclick = () => {
                    const settingsToExport = {
                        quickReplies: CONFIG.QUICK_REPLIES,
                        conversationTarget: CONFIG.CONVERSATION_TARGET,
                        darkMode: CONFIG.DARK_MODE,
                        inactivityClientAlertSeconds: CONFIG.INACTIVITY_CLIENT_ALERT_SECONDS,
                        inactivityOperatorAlertSeconds: CONFIG.INACTIVITY_OPERATOR_ALERT_SECONDS,
                        longConvoAlertMin: CONFIG.LONG_CONVO_ALERT_MIN,
                        hotkeys: CONFIG.HOTKEYS,
                        version: '42.53', // Updated version for backup file
                        popupPositions: CONFIG.POPUP_POSITIONS,
                        miniDashboardVisible: CONFIG.MINI_DASHBOARD_VISIBLE,
                        timerColors: CONFIG.TIMER_COLORS,
                        analyticsData: analyticsManager.getData() // Include analytics data in backup
                    };
                    const blob = new Blob([JSON.stringify(settingsToExport, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a'); a.href = url; a.download = `backup_purecloud_script_v42.53_${getBrazilTime(new Date()).toISOString().split('T')[0]}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
                    UI.createNotification("Configurações exportadas com sucesso!", "success");
                };
                panel.querySelector('#import-btn').onclick = () => panel.querySelector('#import-file-input').click();
                panel.querySelector('#import-file-input').onchange = e => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = event => {
                        try {
                            const imported = JSON.parse(event.target.result);
                            if (imported.quickReplies && imported.conversationTarget !== undefined) {
                                // Apply imported settings
                                CONFIG.QUICK_REPLIES = imported.quickReplies.map(r => ({ ...r, isFavorite: r.isFavorite || false }));
                                CONFIG.CONVERSATION_TARGET = imported.conversationTarget;
                                CONFIG.DARK_MODE = imported.darkMode || false;
                                CONFIG.INACTIVITY_CLIENT_ALERT_SECONDS = imported.inactivityClientAlertSeconds || 70;
                                CONFIG.INACTIVITY_OPERATOR_ALERT_SECONDS = imported.inactivityOperatorAlertSeconds || 30;
                                CONFIG.LONG_CONVO_ALERT_MIN = imported.longConvoAlertMin || 15;
                                CONFIG.HOTKEYS = imported.hotkeys || {};
                                CONFIG.POPUP_POSITIONS = imported.popupPositions || {};
                                CONFIG.MINI_DASHBOARD_VISIBLE = (imported.miniDashboardVisible === undefined ? true : imported.miniDashboardVisible);
                                CONFIG.TIMER_COLORS = {
                                    normalText: imported.timerColors?.normalText || '#ffffff',
                                    inactiveText: imported.timerColors?.inactiveText || '#fdd835',
                                    pausedText: imported.timerColors?.pausedText || '#f44336',
                                    normalBg: imported.timerColors?.normalBg || '#313131',
                                    completedBg: imported.timerColors?.completedBg || '#000000',
                                    completedText: imported.timerColors?.completedText || '#ffffff',
                                    operatorInactiveText: imported.timerColors?.operatorInactiveText || '#ADD8E6',
                                    selectedNormalText: imported.timerColors?.selectedNormalText || '#ffffff',
                                    selectedInactiveText: imported.timerColors?.selectedInactiveText || '#fdd835',
                                    selectedPausedText: imported.timerColors?.selectedPausedText || '#f44336',
                                    selectedNormalBg: imported.timerColors?.selectedNormalBg || '#313131',
                                };
                                // Restore analytics data if present in backup
                                if (imported.analyticsData) {
                                    analyticsManager.saveData(imported.analyticsData);
                                }
                                
                                UI.createNotification("Configurações importadas! Clique em Salvar e Fechar para aplicar.", "info", 5000);
                                // Re-render necessary UI elements to reflect imported settings
                                renderReplies(); // Re-renderizes replies tab
                                panel.querySelector('#conversation-target').value = CONFIG.CONVERSATION_TARGET;
                                panel.querySelector('#dark-mode-toggle').checked = CONFIG.DARK_MODE;
                                panel.querySelector('#inactivity-client-alert-seconds').value = CONFIG.INACTIVITY_CLIENT_ALERT_SECONDS;
                                panel.querySelector('#inactivity-operator-alert-seconds').value = CONFIG.INACTIVITY_OPERATOR_ALERT_SECONDS;
                                panel.querySelector('#long-convo-alert-min').value = CONFIG.LONG_CONVO_ALERT_MIN;
                                UI.renderHotkeysContent(panel.querySelector('[data-tab-content="hotkeys"]')); // Re-renderizes hotkeys tab
                                UI.renderColorsContent(panel.querySelector('[data-tab-content="colors"]')); // Re-renderizes colors tab
                                UI.renderDetailsContent(panel.querySelector('[data-tab-content="details"]')); // Re-render details tab
                                UI.renderAnalyticsContent(panel.querySelector('[data-tab-content="analytics"]')); // Re-render analytics tab
                            } else {
                                UI.createNotification("Arquivo de backup inválido ou incompleto.", "error");
                            }
                        } catch (err) {
                            UI.createNotification("Erro ao ler o arquivo de backup. Verifique o formato.", "error");
                            log("Erro ao importar backup:", err);
                        }
                    };
                    reader.readAsText(file);
                };
            };
            UI.renderBackupContent(panel.querySelector('[data-tab-content="backup"]'));
            // Manual Content (already defined in UI.renderManualContent, just call it)
            UI.renderManualContent(panel.querySelector('[data-tab-content="manual"]'));


            // Common event listeners for settings panel
            panel.querySelector('[data-tab-content="replies"]').addEventListener('click', e => {
                if(e.target.id === 'add-reply-btn') {
                    const list = panel.querySelector('#quick-replies-list');
                    const newItem = document.createElement('div');
                    newItem.className = 'reply-item';
                    newItem.innerHTML = `<input type="checkbox" class="favorite-toggle" title="Marcar como favorito"><input type="text" value="" class="reply-title" placeholder="Categoria - Título"><textarea class="reply-text" placeholder="Texto da Resposta"></textarea><button class="remove-reply-btn" title="Remover">🗑️</button><button class="purecloud-script-button button-secondary copy-reply-settings" data-text="" style="padding: 5px 10px;">Copiar</button>`;
                    list.appendChild(newItem);
                }
                if (e.target.id === 'restore-replies-btn') {
                    if (confirm("Tem certeza que deseja apagar suas respostas atuais e restaurar a lista padrão?")) {
                        CONFIG.QUICK_REPLIES = initialQuickReplies;
                        renderReplies();
                        UI.createNotification("Lista padrão restaurada. Clique em Salvar.", "info");
                    }
                }
                if (e.target.classList.contains('remove-reply-btn')) {
                    e.target.closest('.reply-item').remove();
                }
            });

            panel.querySelector('#reset-counter-btn').onclick = () => {
                if (confirm("Tem certeza que deseja resetar TODOS os contadores diários e as conquistas do dia? Isso não pode ser desfeito.")) {
                    analyticsManager.clearAllData();
                    UI.createNotification("Contadores diários e conquistas resetados com sucesso!", 'success');
                    // Atualiza as abas de analytics e detalhes após o reset
                    UI.renderDetailsContent(panel.querySelector('[data-tab-content="details"]'));
                    UI.renderAnalyticsContent(panel.querySelector('[data-tab-content="analytics"]'));
                }
            };
            
            panel.querySelector('#save-settings-btn').onclick = () => {
                const newReplies = [];
                panel.querySelectorAll('.reply-item').forEach(item => {
                    const title = item.querySelector('.reply-title').value.trim();
                    const text = item.querySelector('.reply-text').value.trim();
                    const isFavorite = item.querySelector('.favorite-toggle').checked;
                    if (title && text) newReplies.push({ title, text, isFavorite });
                });
                CONFIG.QUICK_REPLIES = newReplies;
                
                const newHotkeys = {};
                let hasConflict = false;
                let hasInvalidNumericInput = false;

                generalTab.querySelectorAll('input[type="number"]').forEach(input => {
                    const value = parseInt(input.value, 10);
                    if (isNaN(value) || value < 0) {
                        hasInvalidNumericInput = true;
                        input.classList.add('invalid-input');
                        input.title = 'Por favor, insira um número positivo.';
                    } else {
                        input.classList.remove('invalid-input');
                        input.title = '';
                    }
                });

                if (hasInvalidNumericInput) {
                    log("Input numérico inválido detectado. Não salvando as configurações.");
                    return;
                }

                panel.querySelectorAll('.hotkey-input').forEach(input => {
                    const actionName = input.dataset.action;
                    const newCombo = input.value.trim();
                    if (newCombo) {
                        for (const existingAction in newHotkeys) {
                            if (newHotkeys[existingAction] === newCombo) {
                                UI.createNotification(CONFIG.MESSAGES.HOTKEY_CONFLICT(newCombo, featureDescriptions[existingAction]?.title || existingAction, featureDescriptions[actionName]?.title || actionName), 'error', 7000);
                                hasConflict = true;
                                return;
                            }
                        }
                        if (CONFIG.HOTKEYS[actionName] !== newCombo) {
                            for (const originalAction in CONFIG.HOTKEYS) {
                                if (originalAction !== actionName && CONFIG.HOTKEYS[originalAction] === newCombo) {
                                    UI.createNotification(CONFIG.MESSAGES.HOTKEY_CONFLICT(newCombo, featureDescriptions[originalAction]?.title || originalAction, featureDescriptions[actionName]?.title || actionName), 'error', 7000);
                                    hasConflict = true;
                                    return;
                                }
                            }
                        }
                        newHotkeys[actionName] = newCombo;
                    }
                });

                if (hasConflict) {
                    log("Conflito de atalho detectado. Não salvando as configurações.");
                    return;
                }

                CONFIG.HOTKEYS = newHotkeys;
                CONFIG.CONVERSATION_TARGET = parseInt(panel.querySelector('#conversation-target').value, 10) || 45;
                CONFIG.INACTIVITY_CLIENT_ALERT_SECONDS = parseInt(panel.querySelector('#inactivity-client-alert-seconds').value, 10) || 70;
                CONFIG.INACTIVITY_OPERATOR_ALERT_SECONDS = parseInt(panel.querySelector('#inactivity-operator-alert-seconds').value, 10) || 30;
                CONFIG.LONG_CONVO_ALERT_MIN = parseInt(panel.querySelector('#long-convo-alert-min').value, 10) || 15;
                CONFIG.DARK_MODE = panel.querySelector('#dark-mode-toggle').checked;
                
                CONFIG.TIMER_COLORS = {
                    normalText: panel.querySelector('#timer-color-normal').value,
                    inactiveText: panel.querySelector('#timer-color-inactive').value,
                    pausedText: panel.querySelector('#timer-color-paused').value,
                    normalBg: panel.querySelector('#timer-color-normal-bg').value,
                    completedBg: panel.querySelector('#timer-color-completed-bg').value,
                    completedText: panel.querySelector('#timer-color-completed-text').value,
                    operatorInactiveText: panel.querySelector('#timer-color-operator-inactive').value,
                    selectedNormalText: panel.querySelector('#timer-color-normal').value,
                    selectedInactiveText: panel.querySelector('#timer-color-inactive').value,
                    selectedPausedText: panel.querySelector('#timer-color-paused').value,
                    selectedNormalBg: panel.querySelector('#timer-color-normal-bg').value,
                };

                saveData();
                // updateGlobalCounterText(); // Esta função não é mais usada aqui
                UI.createNotification("Configurações salvas!", "success");
                panel.remove();
                
                // Força a recriação da toolbar para aplicar novos atalhos/estilos
                const toolbarEl = findEl(CONFIG.PURECLOUD_SELECTORS.TOOLBAR);
                if (toolbarEl) {
                    toolbarEl.dataset.scriptVersion = ''; // Reset the flag to force recreation
                    createToolbarUI(toolbarEl);
                }
                document.getElementById('purecloud-script-injected-style')?.remove(); // Remove old styles
                injectCss(); // Inject new styles
            };
        },
        createManualPopup() {
            document.querySelector('.purecloud-script-manual-panel')?.remove();
            const panel = document.createElement('div');
            panel.className = 'purecloud-script-manual-panel purecloud-script-popup';
            panel.innerHTML = `<div class="panel-header"><h2>Manual do Script</h2><div class="panel-header-buttons"><button class="panel-header-btn minimize-btn" title="Minimizar">_</button><button class="panel-header-btn purecloud-script-popup-close-btn" id="closeManualPopupBtn" title="Fechar">X</button></div></div><div class="panel-content" id="manual-content"></div>`;
            document.body.appendChild(panel);
            makeDraggable(panel, panel.querySelector('.panel-header'), 'manualPopup');
            UI.renderManualContent(panel.querySelector('#manual-content'));
            panel.querySelector('#closeManualPopupBtn').onclick = () => panel.remove();
        },
        renderManualContent(container) {
            let html = '<h4>Funcionalidades do Script:</h4>';
            for (const key in featureDescriptions) {
                const feature = featureDescriptions[key];
                let hotkeyInfo = feature.hotkey ? ` (Atalho: <b>${feature.hotkey}</b>)` : '';
                html += `<div class="manual-item"><strong>${feature.title}</strong>${hotkeyInfo}: ${feature.description}</div>`;
            }
            container.innerHTML = html;
        },
        renderDetailsContent(container) {
            // Pega TODAS as conversas registradas, não apenas as "completas"
            const data = analyticsManager.getData();
            const conversations = data.conversations;
            let html = ``;

            if (conversations.length === 0) {
                html += '<div class="item-placeholder">Nenhum atendimento registrado para hoje.</div>';
            } else {
                html += `
                    <div class="details-grid-header">
                        <div class="details-time">Hora Fim</div>
                        <div class="details-client">Cliente</div>
                        <div class="details-tma">TMA</div>
                        <div class="details-tme">TME</div>
                    </div>
                    <div class="details-list-scroll-container"> `;
                // Ordena por timestamp de término para visualização cronológica
                conversations.sort((a, b) => a.timestamp - b.timestamp).forEach((conv, index) => {
                    const convTime = getBrazilTime(new Date(conv.timestamp)).toLocaleTimeString('pt-BR', {hour: '2-digit', minute: '2-digit', second: '2-digit'});
                    const tmaSecs = Math.floor(conv.duration / 1000);
                    const tmeSecs = Math.floor(conv.activeDuration / 1000);
                    html += `
                        <div class="details-grid-item">
                            <div class="details-time">${convTime}</div>
                            <div class="details-client">${conv.participantName || `Atendimento ${index + 1}`}</div>
                            <div class="details-tma">${formatTime(Math.floor(tmaSecs / 60))}:${formatTime(tmaSecs % 60)}</div>
                            <div class="details-tme">${formatTime(Math.floor(tmeSecs / 60))}:${formatTime(tmeSecs % 60)}</div>
                        </div>
                    `;
                });
                html += `</div>`;
            }
            container.innerHTML = html;
        },
        renderAnalyticsContent(container) {
            const stats = analyticsManager.calculateStats();
            const achievements = analyticsManager.getAchievements();
            container.innerHTML = `
                <div id="analytics-content-inner">
                    <div class="stats-grid">
                        <div class="stat-item"><span>Total Atendidos</span><strong>${stats.count}</strong></div>
                        <div class="stat-item"><span>TMA</span><strong>${stats.aht}</strong></div>
                        <div class="stat-item"><span>TME</span><strong>${stats.tme}</strong></div>
                        <div class="stat-item"><span>Início</span><strong>${stats.first}</strong></div>
                        <div class="stat-item"><span>Última</span><strong>${stats.last}</strong></div>
                        <div class="stat-item"><span>Docs Cop.</span><strong>${stats.docCopies}</strong></div>
                        <div class="stat-item"><span>Atalhos Únicos</span><strong>${stats.hotkeysUsed}</strong></div>
                    </div>
                    <h4>Conversas por Hora:</h4>
                    <div class="analytics-chart-container-inner"></div>
                </div>
                <div id="achievements-container">
                    <h4>Conquistas</h4>
                    <div class="achievements-grid"></div>
                </div>`;

            UI.renderBarChart(container.querySelector('.analytics-chart-container-inner'), stats.perHour);
            const achievementsGrid = container.querySelector('.achievements-grid');
            achievementsGrid.innerHTML = Object.entries(achievementsList).map(([key, ach]) => `<div class="achievement-item ${achievements[key]?.unlocked ? 'unlocked' : ''}" title="${ach.description}${achievements[key]?.unlocked ? ' (Desbloqueado em ' + new Date(achievements[key].timestamp).toLocaleDateString('pt-BR') + ')' : ''}">🏆<span>${ach.title}</span></div>`).join('');
        },
        async createQuickReplyPopup() {
            document.querySelector('.purecloud-script-quick-reply-popup')?.remove();
            const popup = document.createElement("div");
            popup.className = 'purecloud-script-quick-reply-popup purecloud-script-popup';

            const favorites = CONFIG.QUICK_REPLIES.filter(r => r.isFavorite);
            // Extrai as categorias únicas da lista de respostas, remove "Geral" para evitar duplicidade
            const categories = [...new Set(CONFIG.QUICK_REPLIES.map(r => r.title.includes(' - ') ? r.title.split(' - ')[0].trim() : 'Geral').filter(c => c && c !== 'Geral'))].sort();
            let categoriesHtml = favorites.length > 0 ? '<button class="category-btn favorite-btn">⭐ Favoritos</button>' : '';
            categoriesHtml += categories.map(c => `<button class="category-btn">${c}</button>`).join('');

            popup.innerHTML = `
                <div class="panel-header">
                    <h3>Respostas Rápidas</h3>
                    <div class="panel-header-buttons">
                        <button class="panel-header-btn minimize-btn" title="Minimizar">_</button>
                        <button class="panel-header-btn purecloud-script-popup-close-btn" id="closeQuickReplyPopupBtn" title="Fechar">X</button>
                    </div>
                </div>
                <div class="panel-content">
                    <input type="text" id="purecloud-script-quick-reply-search" placeholder="Pesquisar...">
                    <div class="categories-container">${categoriesHtml}</div>
                    <div class="items-container"></div>
                </div>`;
            document.body.appendChild(popup);
            makeDraggable(popup, popup.querySelector('.panel-header'), 'quickReplyPopup');

            // --- FIX: Botão de fechar popup de respostas rápidas ---
            popup.querySelector('#closeQuickReplyPopupBtn').onclick = () => popup.remove();


            const itemsContainer = popup.querySelector('.items-container');
            const searchInput = popup.querySelector('#purecloud-script-quick-reply-search');

            const renderReplies = (replies, title = null) => {
                let html = title ? `<h4>${title}</h4>` : '';
                html += !replies.length ? '<div class="item-placeholder">Nenhuma resposta encontrada.</div>' : replies.map(item => `<div class="item" data-text="${encodeURIComponent(item.text)}"><strong>${item.title}</strong><br><small>${item.text}</small></div>`).join('');
                return html;
            };

            const lastMessageEl = findEl(CONFIG.PURECLOUD_SELECTORS.LAST_REMOTE_MESSAGE);
            const lastMessage = lastMessageEl ? lastMessageEl.innerText.toLowerCase() : '';
            let suggestedReplies = [];
            if (lastMessage) {
                const matchedCategories = new Set();
                for (const [category, keywords] of Object.entries(keywordMap)) {
                    // Verifica se alguma palavra-chave da categoria está na última mensagem
                    if (keywords.some(kw => lastMessage.includes(kw))) {
                        matchedCategories.add(category);
                    }
                }
                if (matchedCategories.size > 0) {
                    suggestedReplies = CONFIG.QUICK_REPLIES.filter(r => {
                        const replyCategoryBase = r.title.includes(' - ') ? r.title.split(' - ')[0].trim() : 'Geral';
                        // Uma resposta é sugerida se sua categoria base ou o texto/título contêm as palavras-chave correspondentes
                        return [...matchedCategories].some(cat => 
                            replyCategoryBase.toLowerCase().includes(cat.toLowerCase()) || 
                            r.title.toLowerCase().includes(cat.toLowerCase()) || 
                            r.text.toLowerCase().includes(cat.toLowerCase())
                        );
                    });
                    // Ordena: Favoritos primeiro, depois por mais palavras-chave que correspondem, depois alfabeticamente
                    suggestedReplies.sort((a, b) => {
                        if (a.isFavorite && !b.isFavorite) return -1;
                        if (!a.isFavorite && b.isFavorite) return 1;

                        const aMatchedKeywords = [...matchedCategories].filter(cat => a.title.toLowerCase().includes(cat.toLowerCase()) || a.text.toLowerCase().includes(cat.toLowerCase())).length;
                        const bMatchedKeywords = [...matchedCategories].filter(cat => b.title.toLowerCase().includes(cat.toLowerCase()) || b.text.toLowerCase().includes(cat.toLowerCase())).length;
                        if (bMatchedKeywords !== aMatchedKeywords) return bMatchedKeywords - aMatchedKeywords;

                        return a.title.localeCompare(b.title);
                    });
                }
            }

            let initialHtml = '';
            if (suggestedReplies.length > 0) { initialHtml += renderReplies(suggestedReplies, '💡 Sugestões Baseadas na Última Mensagem'); }
            initialHtml += renderReplies(CONFIG.QUICK_REPLIES.filter(r => !suggestedReplies.includes(r)), 'Todas as Respostas');
            itemsContainer.innerHTML = initialHtml;

            // Event listener para botões de categoria
            popup.querySelector('.categories-container').onclick = e => {
                if (e.target.classList.contains('category-btn')) {
                    popup.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('active'));
                    e.target.classList.add('active');
                    const categoryFilterText = e.target.textContent;

                    let filteredReplies;
                    if (e.target.classList.contains('favorite-btn')) {
                        filteredReplies = CONFIG.QUICK_REPLIES.filter(r => r.isFavorite);
                    } else {
                        filteredReplies = CONFIG.QUICK_REPLIES.filter(r => {
                            // Pega a parte da categoria da resposta (antes do " - ") ou usa "Geral"
                            const rCategory = r.title.includes(' - ') ? r.title.split(' - ')[0].trim() : 'Geral';
                            return rCategory === categoryFilterText;
                        });
                    }
                    itemsContainer.innerHTML = renderReplies(filteredReplies, categoryFilterText === '⭐ Favoritos' ? '⭐ Favoritos' : `Categoria: ${categoryFilterText}`);
                }
            };
            // Event listener para cliques nos itens de resposta
            popup.onclick = async e => {
                if (e.target.closest('.item')) {
                    try {
                        let textToCopy = decodeURIComponent(e.target.closest('.item').dataset.text);
                        const contextText = await documentExtractor.getContextText();
                        const docs = documentExtractor.extractDocuments(contextText);
                        const placeholders = {
                            '\\[NOME DO CLIENTE\\]': documentExtractor.getParticipantName() || '',
                            '\\[SEU NOME\\]': 'Josias Queiroz', // Mantido como fixo
                            '\\[NUMERO\\]': documentExtractor.getInteractionId() || '',
                            '\\[SAUDACAO\\]': getGreeting(),
                            '\\[PROTOCOLO\\]': documentExtractor.getInteractionId() || '', // Duplicado para retrocompatibilidade
                            '\\[CPF_CNPJ\\]': docs.length > 0 ? docs[0] : ''
                        };
                        // Substitui placeholders estáticos
                        for (const [key, value] of Object.entries(placeholders)) {
                            if (value !== undefined) {
                                textToCopy = textToCopy.replace(new RegExp(key, 'gi'), value);
                            }
                        }
                        
                        // Handle dynamic placeholders requiring user input like [DATA], [HORA], [LINK PARA SEGUNDA VIA]
                        let customPlaceholders = textToCopy.match(/\[([A-Z_ ]+)\]/g); // Captura [QUALQUER COISA MAIÚSCULA COM ESPAÇOS]
                        if (customPlaceholders) {
                            // Remove duplicatas
                            customPlaceholders = [...new Set(customPlaceholders)];
                            for (let i = 0; i < customPlaceholders.length; i++) {
                                let placeholder = customPlaceholders[i];
                                let key = placeholder.replace(/[\[\]]/g, '');
                                let promptText = `Por favor, insira o valor para: ${key}`;
                                // Prompt customizado para placeholders específicos
                                if (key === 'DATA') promptText = 'Por favor, insira a DATA (ex: 27/07/2025):';
                                else if (key === 'HORA') promptText = 'Por favor, insira a HORA (ex: 14h30):';
                                else if (key === 'LINK PARA SEGUNDA VIA') promptText = 'Por favor, insira o LINK PARA SEGUNDA VIA:';
                                else if (key === 'LINK PARA SUPORTE TÉCNICO') promptText = 'Por favor, insira o LINK PARA SUPORTE TÉCNICO:';
                                else if (key === 'NOME DO CANAL') promptText = 'Por favor, insira o NOME DO CANAL:';
                                else if (key === 'QUANTIDADE') promptText = 'Por favor, insira a QUANTIDADE (ex: 24 horas):';
                                else if (key === 'NOME DO SERVIÇO') promptText = 'Por favor, insira o NOME DO SERVIÇO:'; // Adicionado
                                
                                let value = prompt(promptText);
                                if (value !== null) {
                                    // Escapa caracteres especiais do placeholder antes de criar a RegExp
                                    textToCopy = textToCopy.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), value);
                                } else {
                                    // Se o usuário cancelar, remove o placeholder
                                    textToCopy = textToCopy.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), '');
                                }
                            }
                        }

                        if (await copyTextToClipboard(textToCopy)) {
                            this.createNotification("Resposta rápida copiada!", "info");
                            popup.remove(); // Fecha o popup após copiar
                        } else {
                            this.createNotification(CONFIG.MESSAGES.COPY_ERROR, 'error');
                            log("Erro ao copiar com placeholders:", err);
                        }
                    } catch (err) {
                        this.createNotification(CONFIG.MESSAGES.COPY_ERROR, 'error');
                        log("Erro ao copiar com placeholders:", err);
                    }
                }
            };
            // Event listener para a barra de pesquisa
            searchInput.oninput = () => {
                const searchTerm = searchInput.value.toLowerCase();
                itemsContainer.innerHTML = renderReplies(CONFIG.QUICK_REPLIES.filter(rp => (rp.title + rp.text).toLowerCase().includes(searchTerm)), `Resultados para "${searchInput.value}"`);
            };
            searchInput.focus();
        },
        createNotepadPanel() {
            document.querySelector('.purecloud-script-notepad-panel')?.remove();
            const panel = document.createElement("div");
            panel.className = 'purecloud-script-notepad-panel purecloud-script-popup';

            // Get interaction ID for title and storage key
            const interactionId = documentExtractor.getInteractionId();
            if (!interactionId) {
                UI.createNotification("Selecione uma conversa para usar o bloco de notas.", "error");
                return;
            }

            panel.innerHTML = `
                <div class="panel-header">
                    <h4>Bloco de Notas (${interactionId})</h4>
                    <div class="panel-header-buttons">
                        <button class="panel-header-btn minimize-btn" title="Minimizar">_</button>
                        <button class="panel-header-btn purecloud-script-popup-close-btn" id="closeNotepadPanelBtn" title="Fechar">X</button>
                    </div>
                </div>
                <div class="panel-content">
                    <textarea id="notepad-textarea" placeholder="Suas anotações para esta conversa..."></textarea>
                </div>`;
            document.body.appendChild(panel);
            makeDraggable(panel, panel.querySelector('.panel-header'), 'notepadPanel');
            const textarea = panel.querySelector('#notepad-textarea');
            textarea.value = localStorage.getItem(`notepad_${interactionId}`) || '';
            textarea.focus();
            // Salva o conteúdo do notepad automaticamente a cada segundo de inatividade na digitação
            textarea.oninput = throttle(() => { localStorage.setItem(`notepad_${interactionId}`, textarea.value); }, 1000);
            panel.querySelector('#closeNotepadPanelBtn').onclick = () => panel.remove();
            log(`[Notepad] Bloco de notas para interação ${interactionId} aberto.`);
        },
        createMiniDashboard() {
            if (document.getElementById('purecloud-script-mini-dashboard')) {
                log("[Mini-Dashboard] Mini-dashboard já existe. Apenas atualizando estatísticas.");
                const dashboard = document.getElementById('purecloud-script-mini-dashboard');
                // Chama a função de atualização interna se já existe
                if (dashboard && dashboard._updateStatsInternal) {
                    dashboard._updateStatsInternal();
                }
                return;
            }
            if (!CONFIG.MINI_DASHBOARD_VISIBLE) {
                log("[Mini-Dashboard] Mini-dashboard configurado para não ser visível.");
                return;
            }

            const dashboard = document.createElement('div');
            dashboard.id = 'purecloud-script-mini-dashboard';
            dashboard.className = 'purecloud-script-popup';
            // Modificando o innerHTML para colocar o mini-dashboard-counter-section primeiro
            dashboard.innerHTML = `
                <div class="panel-header">
                    <h4>Produtividade Hoje</h4>
                    <div class="panel-header-buttons">
                        <button class="panel-header-btn minimize-btn" title="Minimizar">_</button>
                        <button class="panel-header-btn purecloud-script-mini-dashboard-settings-btn" title="Configurações">⚙️</button> 
                        <button class="panel-header-btn purecloud-script-popup-close-btn" id="closeMiniDashboardBtn" title="Fechar">X</button>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="mini-dashboard-counter-section">
                        <div id="mini-dashboard-global-counter">
                            <div class="counter-text">0/${CONFIG.CONVERSATION_TARGET}</div>
                            <div class="progress-bar-container"><div class="progress-bar" style="width: 0%;"></div></div>
                        </div>
                        <button id="mini-dashboard-adjust-attended-btn" class="purecloud-script-button purecloud-script-button-secondary" title="Ajustar Conversas Atendidas">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width: 16px; height: 16px; vertical-align: middle;"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                        </button>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-item"><span>Conversas</span><strong id="dashboard-conv-count">0</strong></div>
                        <div class="stat-item"><span>TMA</span><strong id="dashboard-tma">00:00</strong></div>
                        <div class="stat-item"><span>TME</span><strong id="dashboard-tme">00:00</strong></div>
                    </div>
                </div>
            `;
            document.body.appendChild(dashboard);
            makeDraggable(dashboard, dashboard.querySelector('.panel-header'), 'miniDashboard');

            // Define a função de atualização internamente e a expõe para ser chamada de fora
            dashboard._updateStatsInternal = () => {
                const stats = analyticsManager.calculateStats();
                log("[Mini-Dashboard] Atualizando estatísticas:", stats); // DEBUG

                // Update the X/Y counter and progress bar in mini-dashboard
                const miniCounterEl = document.getElementById('mini-dashboard-global-counter');
                if (miniCounterEl) {
                    const progress = (stats.count / CONFIG.CONVERSATION_TARGET) * 100;
                    miniCounterEl.querySelector('.counter-text').textContent = `${stats.count}/${CONFIG.CONVERSATION_TARGET}`;
                    miniCounterEl.querySelector('.progress-bar').style.width = `${Math.min(100, progress)}%`;
                }
                // Agora, atualize os outros itens da grid de estatísticas
                document.getElementById('dashboard-conv-count').textContent = stats.count; // Total Atendidos
                document.getElementById('dashboard-tma').textContent = stats.aht;
                document.getElementById('dashboard-tme').textContent = stats.tme;
            };

            dashboard._updateInterval = setInterval(dashboard._updateStatsInternal, 5000); // Atualiza a cada 5 segundos
            dashboard._updateStatsInternal(); // Chama uma vez na criação para preencher imediatamente
            
            dashboard.querySelector('#closeMiniDashboardBtn').onclick = () => {
                clearInterval(dashboard._updateInterval);
                dashboard.remove();
                CONFIG.MINI_DASHBOARD_VISIBLE = false;
                saveData();
                log("Mini-dashboard ocultado e estado salvo.");
            };
            dashboard.querySelector('.minimize-btn').onclick = (e) => {
                e.stopPropagation();
                const isMinimized = dashboard.classList.toggle('minimized');
                log(`[Mini-Dashboard] Mini-dashboard ${isMinimized ? 'minimizado' : 'restaurado'}.`);
            };
            dashboard.querySelector('.purecloud-script-mini-dashboard-settings-btn').onclick = () => {
                UI.createSettingsPanel();
                log("[Mini-Dashboard] Painel de configurações aberto do mini-dashboard.");
            };
            // Event listener para o novo botão de ajustar no mini-dashboard
            dashboard.querySelector('#mini-dashboard-adjust-attended-btn').onclick = () => {
                const currentAttendedCount = analyticsManager.calculateStats().count; // Pega a contagem de conversas atendidas (>= threshold)
                const newCount = prompt("Insira o novo número de conversas atendidas (para o dashboard e analytics):", currentAttendedCount);
                if (newCount !== null && !isNaN(newCount)) {
                    const parsedNewCount = parseInt(newCount, 10);
                    if (parsedNewCount < 0) { // Não permitir valores negativos
                        UI.createNotification("O número deve ser positivo.", "error", 4000);
                        return;
                    }
                    
                    let data = analyticsManager.getData();
                    let currentCompletedConvos = data.conversations.filter(c => c.duration >= CONFIG.CHECKMARK_THRESHOLD_MS); // Use data.conversations
                    
                    // Se o novo número é maior, adicionar conversas simuladas
                    if (parsedNewCount > currentCompletedConvos.length) {
                        const diff = parsedNewCount - currentCompletedConvos.length;
                        for (let i = 0; i < diff; i++) {
                            // Adiciona conversas simuladas que ultrapassam o threshold de forma que contem
                            // Duração e activeDuration são definidos acima do threshold para garantir que sejam contadas como "atendidas"
                            data.conversations.push({ 
                                timestamp: Date.now() - (i * 1000), // Simula timestamps decrescentes
                                duration: CONFIG.CHECKMARK_THRESHOLD_MS + 5000, // Acima do threshold
                                activeDuration: CONFIG.CHECKMARK_THRESHOLD_MS + 2000, // TME também acima
                                participantName: "Ajuste Manual"  
                            });
                        }
                        analyticsManager.saveData(data); // Salva os dados atualizados
                        UI.createNotification(`Contador de atendimentos ajustado para ${parsedNewCount}.`, "success");
                    } 
                    // Se o novo número é menor, a única forma de 'diminuir' é resetar tudo
                    else if (parsedNewCount < currentCompletedConvos.length) {
                        UI.createNotification("Para reduzir a contagem de atendimentos, use 'Resetar Contadores Diários' nas configurações. Isso limpará todos os dados do dia.", "warn", 7000);
                    }
                    
                    dashboard._updateStatsInternal(); // Atualiza o mini-dashboard imediatamente
                    // Força a atualização do analytics para recalcular tudo e refletir no painel
                    const settingsPanel = document.querySelector('.purecloud-script-settings-panel');
                    if (settingsPanel && settingsPanel.querySelector('[data-tab-content="analytics"]')?.classList.contains('active')) {
                         UI.renderAnalyticsContent(settingsPanel.querySelector('[data-tab-content="analytics"]'));
                    }
                    if (settingsPanel && settingsPanel.querySelector('[data-tab-content="details"]')?.classList.contains('active')) {
                         UI.renderDetailsContent(settingsPanel.querySelector('[data-tab-content="details"]'));
                    }
                }
            };
            log("Mini-dashboard criado.");
        }
    };

    /**
     * Copia texto para a área de transferência, com fallback para `document.execCommand('copy')`.
     * @param {string} text - O texto a ser copiado.
     * @returns {Promise<boolean>} True se copiado com sucesso, false caso contrário.
     */
    async function copyTextToClipboard(text) {
        try {
            await navigator.clipboard.writeText(text);
            return true;
        } catch (err) {
            log('❌ FALHA AO COPIAR para a área de transferência (API Clipboard). Tentando fallback.', err);
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = text;
            tempTextArea.style.position = 'absolute';
            tempTextArea.style.left = '-9999px';
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            tempTextArea.setSelectionRange(0, 99999);
            try {
                document.execCommand('copy');
                document.body.removeChild(tempTextArea);
                return true;
            } catch (err2) {
                log('❌ FALHA NO FALLBACK AO COPIAR (execCommand).', err2);
                document.body.removeChild(tempTextArea);
                return false;
            }
        }
    }

    const actions = {
        copyDoc: async () => {
            const text = await documentExtractor.getContextText();
            const docs = documentExtractor.extractDocuments(text);
            if (docs.length === 0) {
                UI.createNotification(CONFIG.MESSAGES.NOT_FOUND_DOCUMENT, 'error');
            } else if (docs.length === 1) {
                const doc = docs[0];
                const type = doc.length === 11 ? 'CPF' : 'CNPJ';
                if (await copyTextToClipboard(doc)) {
                    UI.createNotification(`${type} copiado com sucesso!`, 'success');
                    analyticsManager.logDocCopy();
                } else {
                    UI.createNotification(CONFIG.MESSAGES.COPY_ERROR, 'error');
                }
            } else {
                UI.createDocumentPopup(docs);
            }
        },
        copyInteraction: async () => {
            const name = documentExtractor.getParticipantName();
            const btn = findEl(CONFIG.PURECLOUD_SELECTORS.NATIVE_COPY_BUTTON);
            if (!name || !btn) {
                UI.createNotification(CONFIG.MESSAGES.NOT_FOUND_INTERACTION_DATA, 'error');
                return;
            }
            btn.click(); // Simula o clique no botão nativo para copiar a URL
            setTimeout(async () => { // Pequeno delay para a URL ser copiada para a clipboard
                try {
                    const url = await navigator.clipboard.readText();
                    if (url && url.includes('interactions/')) {
                        if (await copyTextToClipboard(`${name || 'Nome Indisponível'} - ${url}`)) {
                            UI.createNotification("Interação copiada com sucesso!", 'success');
                        } else {
                            UI.createNotification(CONFIG.MESSAGES.COPY_ERROR, 'error');
                        }
                    } else {
                        UI.createNotification("Link da interação não encontrado após cópia nativa.", 'error');
                    }
                }
                catch (e) {
                    UI.createNotification(CONFIG.MESSAGES.COPY_ERROR, 'error');
                    log("Erro ao copiar URL da interação:", e);
                }
            }, 150); // Ajuste este delay se a cópia nativa for lenta
        },
        copyAll: async () => {
            const text = await documentExtractor.getContextText();
            const docs = documentExtractor.extractDocuments(text);
            const name = documentExtractor.getParticipantName();
            const id = documentExtractor.getInteractionId();
            let clipText = `Cliente: ${name || 'N/A'}\nProtocolo: ${id || 'N/A'}\n`;
            if(docs.length > 0) {
                clipText += `Documentos: ${docs.map(d => d.length === 11 ? d.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4') : d.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5')).join(', ')}\n`;
            }
            if (await copyTextToClipboard(clipText)) {
                UI.createNotification(CONFIG.MESSAGES.ALL_DATA_COPIED, 'success');
            } else {
                UI.createNotification(CONFIG.MESSAGES.COPY_ERROR, 'error');
            }
        },
        copyFullChat: async () => {
            log("Iniciando tentativa de copiar o histórico da conversa...");
            let chatHistoryContainer = null;
            let finalText = '';
            let searchRoot = document;
            let contextDescription = 'documento principal';
            let historySelectorsToUse = CONFIG.PURECLOUD_SELECTORS.FULL_CHAT_HISTORY_CONTAINER_MAIN_DOC;

            log(`Tentando encontrar iframe do chat por SRC: "${CONFIG.PURECLOUD_SELECTORS.MESSAGING_GADGET_IFRAME}".`);
            const messagingIframe = document.querySelector(CONFIG.PURECLOUD_SELECTORS.MESSAGING_GADGET_IFRAME);

            if (messagingIframe) {
                try {
                    if (messagingIframe.contentDocument) {
                        log("Iframe do chat encontrado e contentDocument acessível. Buscando dentro do iframe.");
                        searchRoot = messagingIframe.contentDocument;
                        contextDescription = 'iframe';
                        historySelectorsToUse = CONFIG.PURECLOUD_SELECTORS.FULL_CHAT_HISTORY_CONTAINER_IN_IFRAME;
                    } else {
                        log("WARN: Iframe do chat encontrado por SRC, mas contentDocument inacessível (provável SecurityError/Cross-Origin). Tentando buscar no documento principal.");
                    }
                } catch (e) {
                    log("ERROR: Erro inesperado ao tentar acessar contentDocument do iframe. Continuando a busca no documento principal.", e);
                }
            } else {
                log("Iframe do chat NÃO encontrado por SRC. Tentando buscar no documento principal.");
            }

            log(`Procurando histórico com seletores: "${historySelectorsToUse.join(' | ')}" no contexto do ${contextDescription}.`);
            chatHistoryContainer = findEl(historySelectorsToUse, searchRoot);

            if (!chatHistoryContainer && searchRoot === document) {
                log("WARN: Container não encontrado no contexto primário. Tentando seletores de container principal (fora do iframe) como fallback final.");
                chatHistoryContainer = findEl(CONFIG.PURECLOUD_SELECTORS.FULL_CHAT_HISTORY_CONTAINER_MAIN_DOC, document);
                contextDescription = 'documento principal (fallback final)';
            }

            if (chatHistoryContainer) {
                log(`Container principal do chat FINALMENTE ENCONTRADO em ${contextDescription}: ${chatHistoryContainer.tagName}${chatHistoryContainer.id ? '#' + chatHistoryContainer.id : ''}${chatHistoryContainer.className ? '.' + chatHistoryContainer.className.split(' ').join('.') : ''}.`);

                log("Tentando rolar para forçar o carregamento de todas as mensagens...");
                // Simula rolagem para carregar mensagens Lazy-Loaded
                chatHistoryContainer.scrollTop = 0;
                await new Promise(resolve => setTimeout(resolve, 100));
                chatHistoryContainer.scrollTop = chatHistoryContainer.scrollHeight;
                await new Promise(resolve => setTimeout(resolve, 100));
                chatHistoryContainer.scrollTop = 0; // Volta para o topo para copiar o início
                await new Promise(resolve => setTimeout(resolve, 100));

                finalText = chatHistoryContainer.innerText.trim(); // Tenta pegar o texto completo
                log(`Tentativa 1: innerText do container principal. Comprimento: ${finalText.length} caracteres.`);

                if (finalText.length < 50) { // Se o innerText for muito pequeno, tenta pegar de elementos de mensagem
                    log("WARN: innerText do container principal é vazio/pequeno. Tentando coletar mensagens individuais de seus filhos.");
                    const chatMessageElements = chatHistoryContainer.querySelectorAll(CONFIG.PURECLOUD_SELECTORS.CHAT_MESSAGE_ELEMENTS.join(', '));
                    let collectedMessages = [];

                    if (chatMessageElements.length > 0) {
                        log(`Encontrados ${chatMessageElements.length} elementos de mensagem. Coletando texto...`);
                        chatMessageElements.forEach(msgEl => {
                            const msgText = msgEl.innerText ? msgEl.innerText.trim() : '';
                            if (msgText) {
                                collectedMessages.push(msgText);
                            }
                        });
                        finalText = collectedMessages.filter(Boolean).join('\n\n--- NOVA MENSAGEM ---\n\n');
                        log(`Texto coletado de mensagens individuais. Comprimento: ${finalText.length} caracteres.`);
                    } else {
                        log("WARN: Nenhum elemento de mensagem individual encontrado dentro do container principal.");
                        finalText = '';
                    }
                }

                if (finalText.length > 0) {
                    if (await copyTextToClipboard(finalText)) {
                        UI.createNotification(CONFIG.MESSAGES.FULL_CHAT_COPIED, 'success');
                        log("✅ SUCESSO! Histórico completo da conversa copiado para a área de transferência.");
                        log('Pode colar (Ctrl+V) em qualquer lugar.');
                    } else {
                        UI.createNotification(CONFIG.MESSAGES.COPY_ERROR, 'error');
                        log('❌ FALHA AO COPIAR. O navegador pode ter bloqueado o comando.');
                    }
                } else {
                    UI.createNotification(`Erro: ${CONFIG.MESSAGES.SELECTOR_NOT_FOUND("o histórico de conversa")}`, 'error', 7000);
                }

            } else {
                log(`❌ ERRO FINAL: Nenhum container principal do histórico de chat encontrado APÓS TODAS AS TENTATIVAS.`);
                log(`Seletor de iframe por SRC: "${CONFIG.PURECLOUD_SELECTORS.MESSAGING_GADGET_IFRAME}"`);
                log(`Seletores tentados no iframe: "${CONFIG.PURECLOUD_SELECTORS.FULL_CHAT_HISTORY_CONTAINER_IN_IFRAME.join(' | ')}"`);
                log(`Seletores tentados no documento principal: "${CONFIG.PURECLOUD_SELECTORS.FULL_CHAT_HISTORY_CONTAINER_MAIN_DOC.join(' | ')}"`);
                log('Isso pode indicar uma mudança significativa na estrutura do DOM do PureCloud ou um problema de carregamento.');
                UI.createNotification(`Erro: ${CONFIG.MESSAGES.SELECTOR_NOT_FOUND("o histórico de conversa")}`, 'error', 7000);
            }
        },
        openYoda: async () => {
            let targetLink = null;
            let searchScope = document;

            const scriptIframe = findEl(CONFIG.PURECLOUD_SELECTORS.SCRIPT_IFRAME);
            if (scriptIframe && scriptIframe.contentDocument) {
                searchScope = scriptIframe.contentDocument;
            }

            const yodaSpans = searchScope.querySelectorAll('span');
            for (const span of yodaSpans) {
                if (span.textContent.includes('Chamado Yoda:')) {
                    let potentialLink = span.nextElementSibling;
                    if (potentialLink && potentialLink.matches('a.cc-editable.link-component') && potentialLink.textContent.trim() === 'Clique aqui') {
                        targetLink = potentialLink;
                        break;
                    }

                    const parentContainer = span.closest('div');
                    if (parentContainer) {
                        potentialLink = parentContainer.querySelector('a.cc-editable.link-component');
                        if (potentialLink && potentialLink.textContent.trim() === 'Clique aqui') {
                            targetLink = potentialLink;
                            break;
                        }
                    }
                }
            }

            if (!targetLink) {
                const allGenericLinks = Array.from(searchScope.querySelectorAll('a.cc-editable.link-component'));
                const matchingGenericLinks = allGenericLinks.filter(link => link.textContent.trim() === 'Clique aqui');
                if (matchingGenericLinks.length >= 3) { // Fallback: try the 3rd generic "Clique aqui" link
                    targetLink = matchingGenericLinks[2];
                    log("WARN: Fallback: Usando o terceiro link 'Clique aqui' genérico. Isso pode ser instável se a ordem mudar.");
                }
            }

            if (!targetLink) {
                UI.createNotification(CONFIG.MESSAGES.YODA_LINK_NOT_FOUND, 'error');
                log("Não foi possível encontrar o link do Yoda com as lógicas de busca.");
                return;
            }

            // Intercept window.open to get the dynamic URL before the browser blocks cross-origin access
            const originalWindowOpen = window.open;
            let interceptedUrl = null;

            window.open = function(url, target, features) {
                interceptedUrl = url;
                log("window.open interceptado:", url);
                return originalWindowOpen(url, target, features);
            };

            targetLink.click(); // Simulate click on the link to trigger window.open

            // Small delay to allow window.open to be called
            setTimeout(() => {
                window.open = originalWindowOpen; // Restore original window.open

                const finalLink = interceptedUrl || targetLink.href; // Prefer intercepted URL

                if (finalLink && finalLink !== '#' && finalLink.includes('yoda')) {
                    if (!interceptedUrl) { // If not intercepted (e.g., direct click by user, not script)
                        originalWindowOpen(finalLink, '_blank'); // Open it manually
                        UI.createNotification("Dashboard Yoda aberto (direto)!", "success");
                    } else {
                        // If intercepted, window.open already happened, just notify
                        UI.createNotification("Dashboard Yoda aberto (interceptado)!", "success");
                    }
                } else {
                    UI.createNotification(CONFIG.MESSAGES.YODA_LINK_NOT_FOUND, 'error');
                    log("O link encontrado não é válido para o Yoda ou não contém 'yoda'. Link: ", finalLink);
                }
            }, 100);
        },
        openReplies: () => UI.createQuickReplyPopup(),
        openNotepad: () => UI.createNotepadPanel(),
        openSettings: () => UI.createSettingsPanel(),
        openManual: () => UI.createManualPopup(),
        toggleMiniDashboard: () => {
            const dashboard = document.getElementById('purecloud-script-mini-dashboard');
            if (dashboard) {
                clearInterval(dashboard._updateInterval); // Stop refreshing if hidden
                dashboard.remove();
                CONFIG.MINI_DASHBOARD_VISIBLE = false; // Set visibility to false
                saveData(); // Save the new state
                log("Mini-dashboard ocultado via atalho.");
            } else {
                CONFIG.MINI_DASHBOARD_VISIBLE = true; // Set visibility to true
                saveData(); // Save the new state
                UI.createMiniDashboard(); // Create and show it
                log("Mini-dashboard exibido via atalho.");
            }
        }
    };

    function updateGlobalCounterText() {
        // Esta função agora está OBSOLETA, pois o contador principal foi movido para o mini-dashboard.
        // A lógica de atualização foi integrada diretamente no updateDashboardStats do mini-dashboard.
        log("updateGlobalCounterText chamado, mas a funcionalidade foi movida para o mini-dashboard.");
    }

    /**
     * Cria e gerencia a interface da barra de ferramentas personalizada.
     * @param {HTMLElement} toolbar - O elemento da barra de ferramentas do PureCloud.
     */
    function createToolbarUI(toolbar) {
        // Usa a flag de versão para evitar recriar a toolbar desnecessariamente
        if (toolbar.dataset.scriptVersion === '42.53') { // Atualizado para a nova versão
            // Se já está na versão correta, apenas garante que os botões existem (para re-render em certas situações de DOM)
            // e que o contador da toolbar não está lá (se por algum motivo foi adicionado de novo)
            // (Nenhum contador principal está mais na toolbar)
            toolbar.querySelectorAll('#purecloud-script-toolbar-counter').forEach(el => el.remove()); 
            return;
        }

        // Remove quaisquer elementos anteriores do script para garantir uma recriação limpa
        toolbar.querySelectorAll('.purecloud-script-custom-btn, #purecloud-script-toolbar-counter, .purecloud-script-menu-container').forEach(el => el.remove());
        toolbar.dataset.scriptVersion = '42.53'; // Define a nova versão

        // Helper para criar botões principais da toolbar
        const createMainToolbarBtn = (id, title, svg, onClick, insertBeforeId = null) => {
            const btn = document.createElement("button");
            btn.id = id;
            btn.className = 'purecloud-script-custom-btn'; // Classe CSS para botões customizados
            btn.title = title;
            btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">${svg}</svg>`;
            btn.onclick = onClick;

            // Insere antes de um elemento específico ou no final
            if (insertBeforeId) {
                const referenceNode = toolbar.querySelector(`#${insertBeforeId}`);
                if (referenceNode) {
                    toolbar.insertBefore(btn, referenceNode);
                } else {
                    toolbar.appendChild(btn);
                }
            } else {
                toolbar.appendChild(btn);
            }
            return btn;
        };

        // Adiciona os botões principais (sem o contador de X/Y)
        createMainToolbarBtn('purecloud-script-btn-copyDoc', featureDescriptions.copyDoc.title, '<path d="M7 5H17M7 9H17M7 13H17M7 17H17M3 3V21H21V3H3Z"/>', actions.copyDoc);
        createMainToolbarBtn('purecloud-script-btn-copyInteraction', featureDescriptions.copyInteraction.title, '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"/>', actions.copyInteraction);
        createMainToolbarBtn('purecloud-script-btn-openReplies', featureDescriptions.openReplies.title, '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>', actions.openReplies);
        createMainToolbarBtn('purecloud-script-btn-openYoda', featureDescriptions.openYoda.title, '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>', actions.openYoda);
        
        // Cria o contêiner do menu "Mais Ações"
        const menuContainer = document.createElement('div');
        menuContainer.className = 'purecloud-script-menu-container';
        // Insere o menu após o último botão adicionado (ex: openYoda)
        const lastButton = toolbar.querySelector('#purecloud-script-btn-openYoda');
        if (lastButton) {
            toolbar.insertBefore(menuContainer, lastButton.nextSibling);
        } else {
            toolbar.appendChild(menuContainer);
        }

        // Botão para abrir o menu "Mais Ações"
        const menuButton = document.createElement('button');
        menuButton.id = 'purecloud-script-menu-button';
        menuButton.className = 'purecloud-script-custom-btn';
        menuButton.title = 'Mais Ações';
        menuButton.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 6h16M4 12h16M4 18h16"/></svg>`;
        menuContainer.appendChild(menuButton);

        // Conteúdo do menu suspenso
        const menuContent = document.createElement('div');
        menuContent.className = 'purecloud-script-menu-content';
        menuContainer.appendChild(menuContent);

        // Helper para criar itens dentro do menu
        const createMenuItem = (id, title, svg, onClick) => {
            const item = document.createElement('button');
            item.className = `purecloud-script-menu-item`; // Classe CSS para itens de menu
            item.id = id;
            item.title = title;
            item.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">${svg}</svg><span>${title}</span>`;
            item.onclick = (e) => {
                e.stopPropagation(); // Evita que o clique feche o menu imediatamente
                onClick();
                menuContent.classList.remove('active'); // Fecha o menu após a ação
            };
            menuContent.appendChild(item);
        };

        // Adiciona os itens ao menu "Mais Ações"
        createMenuItem('purecloud-script-menu-copyAll', featureDescriptions.copyAll.title, '<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>', actions.copyAll);
        createMenuItem('purecloud-script-menu-copyFullChat', featureDescriptions.copyFullChat.title, '<path d="M19 19H5V8h14zm-3-8V5h-2v3H8V5H6v3H3v11h16z"/><path d="M12 17h.01"/><path d="M16 17h.01"/><path d="M8 17h.01"/>', actions.copyFullChat);
        createMenuItem('purecloud-script-menu-notepad', featureDescriptions.openNotepad.title, '<path d="M2 6h4"/><path d="M2 10h4"/><path d="M2 14h4"/><path d="M2 18h4"/><rect x="2" y="2" width="20" height="20" rx="2"/><path d="M6 2v20"/></svg>', actions.openNotepad);
        createMenuItem('purecloud-script-menu-settings', featureDescriptions.openSettings.title, '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>', actions.openSettings);
        createMenuItem('purecloud-script-menu-manual', featureDescriptions.openManual.title, '<path d="M4 19.5V15a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v4.5a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2z"/><path d="M12 2a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h0a2 2 0 0 0 2-2V4a2 2 0 0 0-2-2z"/>', actions.openManual);
        createMenuItem('purecloud-script-menu-miniDashboard', featureDescriptions.miniDashboard.title, '<path d="M12 2a10 10 0 1 0 10 10A10 10 0 0 0 12 2z"/><path d="M12 7v5l3 3"/>', actions.toggleMiniDashboard);

        // Lógica para fechar o menu ao clicar fora
        const closeMenuOnOutsideClick = (e) => {
            if (!menuContainer.contains(e.target) && menuContent.classList.contains('active')) {
                menuContent.classList.remove('active');
                document.removeEventListener('click', closeMenuOnOutsideClick);
            }
        };

        menuButton.onclick = (e) => {
            e.stopPropagation();
            const isActive = menuContent.classList.toggle('active');
            if (isActive) {
                document.addEventListener('click', closeMenuOnOutsideClick);
            } else {
                document.removeEventListener('click', closeMenuOnOutsideClick);
            }
        };
    }

    /**
     * Atualiza a exibição do timer para uma conversa específica.
     * Calcula o tempo decorrido com base no estado pausado/ativo.
     * Esta função é chamada a cada TIMER_UPDATE_INTERVAL_MS.
     * @param {Object} timerData - Objeto contendo dados do timer para uma conversa.
     */
    function updateTimerDisplay(timerData) {
        // Verifica se os elementos do timer ainda estão conectados ao DOM antes de manipulá-los
        if (!timerData.div?.isConnected || !timerData.numDiv?.isConnected || !timerData.bubblesContainer?.isConnected) {
            log(`Elementos do timer para ${timerData.participantName} não conectados ao DOM. Limpando.`);
            clearInterval(timerData.intervalId); // Para o setInterval associado
            // Ao remover, registra o TMA e TME
            if (!timerData.tmaLogged) {
                // Acumula o tempo da sessão ativa antes de registrar o TMA final
                if (!timerData.isPaused && timerData.activeSessionStart) {
                    timerData.activeDuration += (Date.now() - timerData.activeSessionStart);
                    timerData.activeSessionStart = null; // Zera para evitar duplicação
                }
                analyticsManager.logConversation(Date.now() - timerData.startTime, timerData.activeDuration, timerData.participantName); // Registra TMA e TME
                timerData.tmaLogged = true; // Marca como logado para não duplicar

                // A contagem global no mini-dashboard é atualizada via analyticsManager.calculateStats
                // que é chamado periodicamente pelo mainLoop e ao fechar a conversa.
                // updateGlobalCounterText(); // Não precisamos mais disso, a atualização do mini-dashboard já cuida
            }
            // Limpa o Map e remove os elementos do DOM
            conversationTimers.delete(timerData.element);
            timerData.div?.remove();
            timerData.numDiv?.remove();
            timerData.checkmarkDiv?.remove();
            timerData.bubblesContainer?.remove();
            return;
        }

        let currentElapsed; // Tempo total da conversa
        if (timerData.isPaused) {
            // Se pausado, o tempo exibido é o tempo total até o momento da pausa
            currentElapsed = timerData.pausedAt - timerData.startTime;
        } else {
            // Se não pausado, calcula o tempo atual desde o início
            currentElapsed = Date.now() - timerData.startTime;
        }
        
        const secs = Math.floor(currentElapsed / 1000);
        timerData.div.textContent = `${formatTime(Math.floor(secs/60))}:${formatTime(secs%60)}`;

        // Lógica de cores do cronômetro: Prioridade: PAUSADO (VERMELHO) > INATIVIDADE OPERADOR (AZUL CLARO) > INATIVIDADE CLIENTE (AMARELO PISCANDO) > NORMAL (BRANCO)
        timerData.div.classList.remove('paused-alert', 'inactive-client-alert', 'normal-timer', 'inactive-operator-alert'); // Limpa TODAS as classes de alerta/normal
        timerData.div.style.removeProperty('animation'); // Remove animação padrão

        if (timerData.isPaused) {
            // Conversa não selecionada (pausada) - Fica VERMELHO
            timerData.div.classList.add('paused-alert');
        } else {
            // Conversa selecionada (ativa) - Verifica inatividade do operador e do cliente
            const inactivityOperatorSeconds = (Date.now() - (timerData.lastOperatorActivityTimestamp || timerData.startTime)) / 1000;
            const inactivityClientSeconds = (Date.now() - (timerData.lastCustomerReplyTimestamp || timerData.startTime)) / 1000;

            if (inactivityOperatorSeconds >= CONFIG.INACTIVITY_OPERATOR_ALERT_SECONDS) {
                // Operador inativo (em conversa ATIVA) - Fica AZUL CLARO
                timerData.div.classList.add('inactive-operator-alert');
            } else if (inactivityClientSeconds >= CONFIG.INACTIVITY_CLIENT_ALERT_SECONDS) {
                // Cliente inativo (em conversa ATIVA) - Fica AMARELO PISCANDO
                timerData.div.classList.add('inactive-client-alert');
            } else {
                // Conversa ativa e sem inatividade prolongada - Fica BRANCO
                timerData.div.classList.add('normal-timer'); // Aplica classe para estilo normal
            }
        }
        
        // Lógica do "Verificado" (✓) - aparece APÓS o cronômetro e não o substitui
        if (currentElapsed >= CONFIG.CHECKMARK_THRESHOLD_MS) {
            if (!timerData.completedVisual) {
                if (!timerData.checkmarkDiv) {
                    timerData.checkmarkDiv = document.createElement('div');
                    timerData.checkmarkDiv.className = 'injected-element injected-checkmark';
                    timerData.checkmarkDiv.innerHTML = '✔️'; // Unicode checkmark
                    timerData.bubblesContainer.appendChild(timerData.checkmarkDiv);
                }
                timerData.checkmarkDiv.style.display = 'flex';
                timerData.completedVisual = true;
            }
        } else {
            if (timerData.checkmarkDiv) {
                timerData.checkmarkDiv.style.display = 'none';
                timerData.completedVisual = false;
            }
        }

        // Alerta de conversa muito longa (notificação popup, apenas uma vez)
        if (currentElapsed > CONFIG.LONG_CONVO_ALERT_MIN * 60000 && !timerData.longConvoNotified) {
            UI.createNotification(`A conversa com ${timerData.participantName || 'o cliente'} está muito longa (${CONFIG.LONG_CONVO_ALERT_MIN} min).`, 'warn', 5000);
            timerData.longConvoNotified = true;
        }
    }

    // Observer para atualizar o lastCustomerReplyTimestamp e lastOperatorActivityTimestamp
    let currentChatObserverInstance = null;
    let currentChatInputField = null;

    function observeCurrentChatMessages() {
        // Desconecta o observer anterior, se houver
        if (currentChatObserverInstance) {
            currentChatObserverInstance.disconnect();
            currentChatObserverInstance = null;
            log("Observer de mensagens do chat desconectado.");
        }
        // Remove listener de input anterior
        if (currentChatInputField) {
            currentChatInputField.removeEventListener('input', handleOperatorActivity);
            currentChatInputField.removeEventListener('keypress', handleOperatorActivity);
            currentChatInputField = null;
        }

        const selectedConvEl = findEl(CONFIG.PURECLOUD_SELECTORS.SELECTED_INTERACTION_GROUP);
        if (!selectedConvEl) {
            log("Nenhuma conversa selecionada para observar mensagens.");
            return;
        }

        const timerData = conversationTimers.get(selectedConvEl);
        if (!timerData) {
            log("Não há timerData para a conversa selecionada para observar mensagens.");
            return;
        }

        let chatMessagesContainer = null;
        let chatInputField = null;

        // Tenta encontrar o iframe do chat primeiro
        const messagingIframe = document.querySelector(CONFIG.PURECLOUD_SELECTORS.MESSAGING_GADGET_IFRAME);

        if (messagingIframe && messagingIframe.contentDocument) {
            try {
                // Tenta encontrar o container e o campo de input dentro do iframe
                chatMessagesContainer = findEl(CONFIG.PURECLOUD_SELECTORS.FULL_CHAT_HISTORY_CONTAINER_IN_IFRAME, messagingIframe.contentDocument);
                chatInputField = findEl(CONFIG.PURECLOUD_SELECTORS.CHAT_INPUT_FIELD, messagingIframe.contentDocument);
                if (chatMessagesContainer) {
                    log("Container de mensagens encontrado no IFRAME para observação.");
                }
            } catch (e) {
                log("WARN: Erro ao acessar contentDocument do iframe de mensagens. Tentando documento principal para observação.", e);
            }
        }
        // Se não encontrou no iframe ou houve erro, tenta no documento principal
        if (!chatMessagesContainer) {
            chatMessagesContainer = findEl(CONFIG.PURECLOUD_SELECTORS.FULL_CHAT_HISTORY_CONTAINER_MAIN_DOC);
            chatInputField = findEl(CONFIG.PURECLOUD_SELECTORS.CHAT_INPUT_FIELD);
            if (chatMessagesContainer) {
                log("Container de mensagens encontrado no DOCUMENTO PRINCIPAL para observação.");
            }
        }

        // Função para monitorar a atividade do operador (digitação)
        const handleOperatorActivity = () => {
            // Atualiza o timestamp da última atividade do operador
            // A comparação com Date.now() impede updates excessivos se o evento disparar muito rapidamente
            if (timerData.lastOperatorActivityTimestamp !== Date.now()) {
                timerData.lastOperatorActivityTimestamp = Date.now();
                updateTimerDisplay(timerData); // Atualiza cor/tempo imediatamente
                // log("Atividade do operador detectada."); // Descomente para depuração de atividade
            }
        };

        if (chatMessagesContainer) {
            // Se o container já está sendo observado, apenas atualiza o listener de input se o campo mudou
            if (chatMessagesContainer.dataset.observedByScript === 'true') {
                log("Container de mensagens já está sendo observado.");
                if (chatInputField && currentChatInputField !== chatInputField) {
                    if (currentChatInputField) {
                        currentChatInputField.removeEventListener('input', handleOperatorActivity);
                        currentChatInputField.removeEventListener('keypress', handleOperatorActivity);
                    }
                    chatInputField.addEventListener('input', handleOperatorActivity);
                    chatInputField.addEventListener('keypress', handleOperatorActivity);
                    currentChatInputField = chatInputField;
                    log("Listener de atividade do operador atualizado para novo campo de chat.");
                }
                return; // Já está observando, não precisa criar um novo observer
            }

            // Cria um novo MutationObserver para o container de mensagens
            currentChatObserverInstance = new MutationObserver((mutations) => {
                for (const mutation of mutations) {
                    if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                        // Detecta novas mensagens do cliente (remoto)
                        const newClientMessages = Array.from(mutation.addedNodes).filter(node =>
                            node.nodeType === 1 && node.matches('.chat-message-group.remote') // Classe para mensagens do cliente
                        );
                        if (newClientMessages.length > 0) {
                            timerData.lastCustomerReplyTimestamp = Date.now(); // Atualiza timestamp da última mensagem do cliente
                            updateTimerDisplay(timerData); // Atualiza o display do timer (para cor de inatividade)
                            log(`Nova mensagem do cliente em ${timerData.participantName}. Resetando alerta de inatividade do cliente.`);
                        }
                    }
                    // NOVO: Destaque de Links/IDs em mensagens
                    mutation.addedNodes.forEach(node => {
                        // Verifica se o nó adicionado ou seus descendentes contêm mensagens de chat
                        if (node.nodeType === 1 && (node.matches('.chat-message-group') || node.matches('.message-body') || node.querySelector('.message-body'))) {
                            highlightChatLinksAndIds(node.querySelector('.message-body') || node); // Garante que é o elemento de texto para destaque
                        }
                    });
                }
            });
            currentChatObserverInstance.observe(chatMessagesContainer, { childList: true, subtree: true }); // Observa filhos e subárvores
            chatMessagesContainer.dataset.observedByScript = 'true'; // Marca que está sendo observado
            log("Observer de mensagens do chat conectado.");

            // NOVO: Monitora a digitação do operador no campo de input
            if (chatInputField) {
                chatInputField.addEventListener('input', handleOperatorActivity);
                chatInputField.addEventListener('keypress', handleOperatorActivity);
                currentChatInputField = chatInputField; // Armazena a referência para remover depois
                log("Monitoramento de atividade do operador iniciado.");
            } else {
                log("WARN: Campo de input do chat não encontrado para monitorar atividade do operador.");
            }

        } else {
            log("WARN: Não foi possível encontrar o container de mensagens para observar.");
        }
    }

    // NOVO: Função para destacar links e IDs no chat
    const highlightChatLinksAndIds = (messageElement) => {
        // Verifica se o elemento já foi processado para evitar duplicação
        if (!messageElement || messageElement.hasAttribute('data-gm-processed')) return;
        
        let processedHTML = messageElement.innerHTML;

        // Regex para URLs (simplificado, pode ser mais robusto)
        const urlRegex = /(https?:\/\/[^\s$.?#].[^\s]*)/g;
        // Regex para números de protocolo Genesys ou similar (ex: apenas números longos 8 a 14 dígitos que não sejam telefones puros)
        const interactionIdRegex = /\b(\d{8,14})\b/g; 

        // Função auxiliar para evitar processar HTML já existente (ex: tags <a>)
        const replaceOutsideTags = (html, regex, replacer) => {
            const parts = html.split(/(<[^>]+>)/g); // Divide por tags HTML
            return parts.map(part => {
                if (part.startsWith('<') && part.endsWith('>')) {
                    return part; // É uma tag, não modifica
                } else {
                    return part.replace(regex, replacer); // É texto, aplica regex
                }
            }).join('');
        };

        // Destaque URLs
        processedHTML = replaceOutsideTags(processedHTML, urlRegex, (match) => {
            // Evita reprocessar links já existentes
            if (match.includes('<a') || match.includes('<span class="purecloud-script-highlighted-link"')) {
                return match;
            }
            return `<a href="${match}" target="_blank" class="purecloud-script-highlighted-link" title="Abrir link">${match}</a>`;
        });

        // Destaque IDs de interação (se não for parte de um link já existente)
        processedHTML = replaceOutsideTags(processedHTML, interactionIdRegex, (match) => {
            // Garante que não está dentro de um <a> existente ou já destacado
            if (match.match(/<a[^>]*>[^<]*<\/a>/) || match.includes('purecloud-script-highlighted-link') || match.includes('purecloud-script-highlighted-id')) {
                return match;
            }
            return `<span class="purecloud-script-highlighted-id" title="Clique para copiar">${match}</span>`;
        });

        if (messageElement.innerHTML !== processedHTML) {
            messageElement.innerHTML = processedHTML;
            messageElement.setAttribute('data-gm-processed', 'true'); // Marca como processado
            log("Links e IDs destacados na mensagem:", messageElement.textContent.substring(0, 50) + "...");

            // Adiciona listener de clique para copiar o ID (apenas nos spans recém-criados)
            messageElement.querySelectorAll('.purecloud-script-highlighted-id').forEach(span => {
                if (!span.dataset.listenerAdded) { // Adiciona apenas uma vez
                    span.addEventListener('click', async (e) => {
                        e.stopPropagation(); // Evita que o clique se propague para outros listeners
                        if (await copyTextToClipboard(span.textContent)) {
                            UI.createNotification(`ID "${span.textContent}" copiado!`, 'success', 1500);
                        } else {
                            UI.createNotification(CONFIG.MESSAGES.COPY_ERROR, 'error');
                        }
                    });
                    span.dataset.listenerAdded = 'true';
                }
            });
        }
    };

    /**
     * Loop principal que gerencia a injeção de UI e atualização dos timers.
     */
    function mainLoop() {
        const toolbar = findEl(CONFIG.PURECLOUD_SELECTORS.TOOLBAR);
        if (toolbar) {
            createToolbarUI(toolbar);
        } else {
            // log("WARN: Toolbar principal do PureCloud não encontrada.");
        }

        let conversationsNodeList = document.querySelectorAll(CONFIG.PURECLOUD_SELECTORS.INTERACTION_GROUP.join(', '));
        // Ordena de cima para baixo para que a numeração DECRESCENTE (N, N-1...) seja aplicada corretamente.
        const sortedConversationsArray = Array.from(conversationsNodeList).sort((a, b) => a.getBoundingClientRect().top - b.getBoundingClientRect().top);

        // Remove os timers de conversas que não estão mais no DOM (conversas finalizadas/fechadas)
        const activeConversationElements = new Set();
        sortedConversationsArray.forEach(convEl => activeConversationElements.add(convEl));

        conversationTimers.forEach((timerData, convEl) => {
            if (!activeConversationElements.has(convEl)) {
                log(`Limpando timer para ${timerData.participantName} removido do DOM.`);
                clearInterval(timerData.intervalId); // Para o setInterval associado
                if (!timerData.tmaLogged) { // Verifica se o TMA/TME já foi logado
                    // Acumula o tempo da sessão ativa antes de registrar o TMA final
                    if (!timerData.isPaused && timerData.activeSessionStart) {
                        timerData.activeDuration += (Date.now() - timerData.activeSessionStart);
                        timerData.activeSessionStart = null; // Zera para evitar duplicação
                    }
                    analyticsManager.logConversation(Date.now() - timerData.startTime, timerData.activeDuration, timerData.participantName); // Registra TMA e TME
                    timerData.tmaLogged = true; // Marca como logado para não duplicar

                    // A contagem global no mini-dashboard é atualizada via analyticsManager.calculateStats
                    // que é chamado periodicamente pelo mainLoop e ao fechar a conversa.
                    // updateGlobalCounterText(); // Não precisamos mais disso, a atualização do mini-dashboard já cuida
                }
                // Limpa o Map e remove os elementos do DOM
                conversationTimers.delete(convEl);
                timerData.div?.remove();
                timerData.numDiv?.remove();
                timerData.checkmarkDiv?.remove();
                timerData.bubblesContainer?.remove();
            }
        });

        // Adiciona ou atualiza timers para as conversas presentes
        sortedConversationsArray.forEach((conv, index) => {
            // Esconde o tempo nativo do PureCloud, se existir, para evitar duplicação.
            const nativeTimeElementsInConv = conv.querySelectorAll('.message-timestamp, .duration, .chat-message-group > div:last-child > span, .chat-message-group > div:last-child > div');
            nativeTimeElementsInConv.forEach(el => {
                // Verifica o texto para evitar esconder elementos que não são tempos
                if (el.textContent.match(/\d+\s*(min|hr|seg|now|agora)/i) || el.matches('.duration, .message-timestamp')) {
                    el.style.display = 'none';
                }
            });


            let tData = conversationTimers.get(conv);

            if (!tData) { // Se o timer para esta conversa ainda não existe, cria um novo
                const bubblesContainer = document.createElement('div');
                bubblesContainer.className = 'injected-bubbles-container';

                const nDiv = document.createElement('div');
                nDiv.className = 'injected-element injected-conversation-number';
                bubblesContainer.appendChild(nDiv);

                const tDiv = document.createElement('div');
                tDiv.className = 'injected-element injected-conversation-timer';
                bubblesContainer.appendChild(tDiv);

                conv.appendChild(bubblesContainer);

                const participantName = documentExtractor.getParticipantName(conv) || `Conversa ${sortedConversationsArray.length - index}`; // Nome genérico para nova conversa

                tData = {
                    div: tDiv,
                    numDiv: nDiv,
                    checkmarkDiv: null, // Para o "check" de TMA
                    bubblesContainer: bubblesContainer,
                    element: conv,
                    startTime: Date.now(), // Inicia o timer quando o card aparece
                    pausedAt: Date.now(), // Define pausedAt igual a startTime inicialmente
                    isPaused: true, // Começa PAUSADO por padrão (não selecionado)
                    completedVisual: false, // Flag para o visual do checkmark
                    tmaLogged: false, // Flag para controle se o TMA já foi logado
                    activeDuration: 0, // Acumulador para o tempo em que a conversa está ativa (selecionada)
                    activeSessionStart: null, // Timestamp do início da sessão ativa atual
                    lastOperatorActivityTimestamp: Date.now(), // Tempo da última atividade do operador (digitação)
                    lastCustomerReplyTimestamp: Date.now(), // Tempo da última mensagem do cliente
                    longConvoNotified: false, // Flag para notificação de conversa longa
                    participantName: participantName // Armazena o nome do participante para logs e notificações
                };

                // Define o intervalo de atualização para este timer específico
                tData.intervalId = setInterval(() => {
                    updateTimerDisplay(tData);
                }, CONFIG.TIMER_UPDATE_INTERVAL_MS);

                conversationTimers.set(conv, tData);
                log(`Novo timer criado para ${participantName}. Começa pausado.`);
            }

            // ATENÇÃO: Numeração invertida de cima para baixo (1 para a conversa mais recente)
            tData.numDiv.textContent = sortedConversationsArray.length - index;

            const isSelected = conv.classList.contains('is-selected');
            if (isSelected) {
                // Se a conversa está selecionada e estava pausada, retoma a contagem de tempo "ativa"
                if (tData.isPaused) {
                    tData.startTime += (Date.now() - tData.pausedAt); // Ajusta o startTime para desconsiderar o tempo de pausa
                    tData.isPaused = false;
                    tData.activeSessionStart = Date.now(); // Inicia a contagem da sessão ativa
                    tData.lastOperatorActivityTimestamp = Date.now(); // Reseta a inatividade do operador ao selecionar
                    log(`Timer para ${tData.participantName} retomado.`);
                }
                observeCurrentChatMessages(); // Conecta o observer de mensagens e input para a conversa ATIVA
            } else {
                // Se a conversa NÃO está selecionada e NÃO estava pausada, pausa o timer
                if (!tData.isPaused) {
                    tData.pausedAt = Date.now(); // Marca o tempo em que foi pausado
                    // Acumula o tempo da sessão ativa antes de pausar
                    if (tData.activeSessionStart) {
                        tData.activeDuration += (Date.now() - tData.activeSessionStart);
                        tData.activeSessionStart = null; // Reseta para a próxima sessão ativa
                    }
                    tData.isPaused = true;
                    log(`Timer para ${tData.participantName} pausado.`);
                }
            }
            // Sempre força a atualização do display para aplicar a cor e o tempo correto (pausado, inativo ou normal)
            updateTimerDisplay(tData);
        });
        // Recalcular e atualizar o mini-dashboard para refletir o estado mais recente
        UI.createMiniDashboard(); // Garante que o dashboard exista
    }

    // --- HANDLER DE ATALHOS DE TECLADO ---
    const keyboardEventHandler = (e) => {
        // Não ativa atalhos se o foco estiver em um campo de texto ou popup aberto
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable || document.querySelector('.purecloud-script-popup')) {
            return;
        }

        const pressedKeys = [];
        if (e.ctrlKey) pressedKeys.push('Control');
        if (e.shiftKey) pressedKeys.push('Shift');
        if (e.altKey) pressedKeys.push('Alt');
        // Adiciona a tecla principal, tratando 'Space' e capitalizando letras
        if (!['Control', 'Shift', 'Alt', 'Meta'].includes(e.key)) {
            pressedKeys.push(e.key === ' ' ? 'Space' : (e.key.length === 1 ? e.key.toUpperCase() : e.key));
        }
        const currentCombo = pressedKeys.join('+');

        for (const actionName in CONFIG.HOTKEYS) {
            if (CONFIG.HOTKEYS[actionName] === currentCombo) {
                e.preventDefault(); // Previne o comportamento padrão do navegador para o atalho
                if (actions[actionName]) {
                    actions[actionName](); // Executa a ação associada ao atalho
                    analyticsManager.logHotkeyUse(actionName); // Registra o uso do atalho
                    UI.createNotification(CONFIG.MESSAGES.HOTKEY_TRIGGERED(featureDescriptions[actionName]?.title || actionName, currentCombo), 'info', 1000);
                    return;
                } else {
                    log(`Ação '${actionName}' para o atalho '${currentCombo}' não encontrada.`);
                    UI.createNotification(CONFIG.MESSAGES.ACTION_NOT_FOUND(actionName), 'error');
                }
            }
        }
    };

    function injectCss() {
        // Remove o estilo anterior antes de injetar o novo
        document.getElementById('purecloud-script-injected-style')?.remove();

        const css = `
            :root {
                /* Cores do Tema Claro (Base, ajustadas pelas configurações customizáveis) */
                --purecloud-script-bg-primary: #ffffff;
                --purecloud-script-bg-secondary: #f0f0f0;
                --purecloud-script-text-primary: #222222;
                --purecloud-script-text-secondary: #555555;
                --purecloud-script-border-color: #dddddd;
                --purecloud-script-accent-color: #4CAF50; /* Verde principal */
                --purecloud-script-accent-text: #ffffff;
                --purecloud-script-warn-color: #f44336; /* Vermelho para alertas/perigo */
                --purecloud-script-favorite-color: #ffc107; /* Amarelo para favoritos */
                --purecloud-script-shadow-color: rgba(0,0,0,0.15);
                --purecloud-script-success-color: #28a745;
                --purecloud-script-error-color: #dc3545;

                /* Cores do Cronômetro (Customizáveis) */
                --purecloud-script-bubble-text-normal: ${CONFIG.TIMER_COLORS.normalText};
                --purecloud-script-bubble-text-timer-inactive: ${CONFIG.TIMER_COLORS.inactiveText};
                --purecloud-script-bubble-text-paused: ${CONFIG.TIMER_COLORS.pausedText};
                --purecloud-script-bubble-text-operator-inactive: ${CONFIG.TIMER_COLORS.operatorInactiveText};
                --purecloud-script-bubble-bg-normal: ${CONFIG.TIMER_COLORS.normalBg};
                --purecloud-script-bubble-bg-paused: ${CONFIG.TIMER_COLORS.normalBg};
                --purecloud-script-bubble-bg-completed: ${CONFIG.TIMER_COLORS.completedBg};
                --purecloud-script-bubble-text-completed: ${CONFIG.TIMER_COLORS.completedText};

                /* Cores do Cronômetro quando o card da conversa está SELECIONADO (Herdam de cima, mas podem ter overrides) */
                --purecloud-script-bubble-bg-selected: var(--purecloud-script-bubble-bg-normal);
                --purecloud-script-bubble-text-selected-number: var(--purecloud-script-bubble-text-normal);
                --purecloud-script-bubble-text-selected-timer: var(--purecloud-script-bubble-text-normal);
                --purecloud-script-bubble-text-selected-timer-inactive: var(--purecloud-script-bubble-text-timer-inactive);
                --purecloud-script-bubble-text-selected-timer-paused: var(--purecloud-script-bubble-text-paused);
                --purecloud-script-bubble-text-selected-operator-inactive: var(--purecloud-script-bubble-text-operator-inactive);
            }

            /* Tema Escuro */
            body.gm-dark-mode {
                --purecloud-script-bg-primary: #1a1a1a !important;
                --purecloud-script-bg-secondary: #252525 !important;
                --purecloud-script-text-primary: #eeeeee !important;
                --purecloud-script-text-secondary: #aaaaaa !important;
                --purecloud-script-border-color: #444444 !important;
                --purecloud-script-accent-color: #6ed36e !important;
                --purecloud-script-accent-text: #ffffff !important;
                --purecloud-script-warn-color: #e57373 !important;
                --purecloud-script-favorite-color: #ffd740 !important;
                --purecloud-script-shadow-color: rgba(0,0,0,0.6) !important;
                --purecloud-script-success-color: #28a745 !important;
                --purecloud-script-error-color: #c82333 !important;

                /* Cores do Cronômetro (Customizáveis) para Dark Mode */
                --purecloud-script-bubble-text-normal: ${CONFIG.TIMER_COLORS.normalText};
                --purecloud-script-bubble-text-timer-inactive: ${CONFIG.TIMER_COLORS.inactiveText};
                --purecloud-script-bubble-text-paused: ${CONFIG.TIMER_COLORS.pausedText};
                --purecloud-script-bubble-text-operator-inactive: ${CONFIG.TIMER_COLORS.operatorInactiveText};
                --purecloud-script-bubble-bg-normal: #000000;
                --purecloud-script-bubble-bg-paused: #000000;
                --purecloud-script-bubble-bg-completed: ${CONFIG.TIMER_COLORS.completedBg};
                --purecloud-script-bubble-text-completed: ${CONFIG.TIMER_COLORS.completedText};

                --purecloud-script-bubble-bg-selected: var(--purecloud-script-bubble-bg-normal);
                --purecloud-script-bubble-text-selected-number: var(--purecloud-script-bubble-text-normal);
                --purecloud-script-bubble-text-selected-timer: var(--purecloud-script-bubble-text-normal);
                --purecloud-script-bubble-text-selected-timer-inactive: var(--purecloud-script-bubble-text-timer-inactive);
                --purecloud-script-bubble-text-selected-timer-paused: var(--purecloud-script-bubble-text-paused);
                --purecloud-script-bubble-text-selected-operator-inactive: var(--purecloud-script-bubble-text-operator-inactive);
            }

            /* Estilos para botões customizados na toolbar */
            .purecloud-script-custom-btn {
                background: var(--purecloud-script-bg-secondary) !important;
                border: 1px solid var(--purecloud-script-border-color) !important;
                padding: 5px 8px !important;
                margin: 0 2px !important;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                transition: all .2s;
                height: 30px;
                order: 3;
                color: var(--purecloud-script-text-secondary) !important;
                border-radius: 4px;
                font-size: 14px;
                text-decoration: none;
                position: relative;
                overflow: hidden;
            }
            .purecloud-script-custom-btn:hover {
                color: var(--purecloud-script-text-primary) !important;
                background-color: var(--purecloud-script-border-color) !important;
                box-shadow: 0 0 8px var(--purecloud-script-accent-color);
                transform: translateY(-1px);
            }
            .purecloud-script-custom-btn:active {
                background-color: var(--purecloud-script-accent-color) !important;
                color: var(--purecloud-script-accent-text) !important;
                box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
                transform: translateY(0);
            }
            .purecloud-script-custom-btn svg {
                stroke: currentColor !important;
                width: 18px;
                height: 18px;
                margin-right: 5px;
                flex-shrink: 0;
            }

            /* Ajuste específico para os itens de menu (dentro do popup "Mais Ações") */
            .purecloud-script-menu-item {
                background: none !important;
                border: none !important;
                border-radius: 0 !important;
                padding: 8px 15px !important;
                margin: 0 !important;
                color: var(--purecloud-script-text-primary) !important;
                text-align: left;
                display: flex;
                align-items: center;
                width: 100%;
                cursor: pointer;
                transition: background-color 0.1s;
                font-size: 0.95em;
            }
            .purecloud-script-menu-item:hover {
                background-color: var(--purecloud-script-bg-secondary) !important;
                box-shadow: none !important;
                transform: none !important;
            }
            .purecloud-script-menu-item:active {
                background-color: var(--purecloud-script-accent-color) !important;
                color: var(--purecloud-script-accent-text) !important;
            }
            .purecloud-script-menu-item svg {
                margin-right: 8px !important;
            }
            .purecloud-script-menu-item span {
                color: inherit;
            }

            /* Contador de Conversas na Toolbar - REMOVIDO DA TOOLBAR */
            #purecloud-script-toolbar-counter { 
                display: none !important; /* Esconde completamente o contador X/Y da toolbar */
            }


            /* Popups gerais (Settings, Quick Replies, Notepad, Manual, Mini-Dashboard) */
            .purecloud-script-popup {
                position: fixed;
                background: var(--purecloud-script-bg-primary);
                border-radius: 8px;
                box-shadow: 0 8px 30px var(--purecloud-script-shadow-color);
                z-index: 10002;
                display: flex;
                flex-direction: column;
                border: 1px solid var(--purecloud-script-border-color);
                transition: opacity 0.2s, transform 0.2s, height 0.2s, width 0.2s;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                margin: 0;
                resize: both; /* Permite redimensionamento em ambas as direções */
                overflow: hidden; /* Garante que o conteúdo seja cortado ao redimensionar */
            }
            .purecloud-script-popup.minimized {
                height: 42px !important; 
                min-height: 42px !important; /* Altura da header */
                width: 250px !important; /* Aumentado para garantir visibilidade dos botões */
                min-width: 250px !important; /* Garante que não fique menor que os botões */
                top: auto !important; 
                bottom: 20px !important; /* Posiciona no canto inferior esquerdo */
                left: 20px !important;
                right: auto !important; /* Desabilita right para fixar left */
                transform: none !important; 
                margin: 0 !important; 
                border-bottom: 1px solid var(--purecloud-script-border-color); /* Volta a borda inferior */
                border-radius: 8px; /* Mantém cantos arredondados */
                overflow: visible; /* Alterado para visível para garantir que os botões não sejam cortados */
            }
            .purecloud-script-popup.minimized .panel-content, 
            .purecloud-script-popup.minimized .panel-footer, 
            .purecloud-script-popup.minimized .purecloud-script-tabs { 
                display: none; 
            }
            .panel-header {
                cursor: move;
                background: var(--purecloud-script-bg-secondary);
                padding: 10px 15px;
                border-bottom: 1px solid var(--purecloud-script-border-color);
                display: flex;
                justify-content: space-between;
                align-items: center;
                border-radius: 8px 8px 0 0;
            }
            .panel-header h2, .panel-header h3, .panel-header h4 { margin: 0; color: var(--purecloud-script-text-primary); font-size: 16px; }
            .panel-header-buttons { display: flex; gap: 5px; }
            .panel-header-btn {
                background: none; border: none; font-size: 1.2em; cursor: pointer;
                color: var(--purecloud-script-text-secondary); padding: 0 5px;
            }
            .panel-content { padding: 15px; overflow-y: auto; flex-grow: 1; background: var(--purecloud-script-bg-primary); color: var(--purecloud-script-text-primary); }
            .panel-footer { padding: 10px 15px; background: var(--purecloud-script-bg-secondary); border-top: 1px solid var(--purecloud-script-border-color); text-align: right; border-radius: 0 0 8px 8px; }
            .purecloud-script-button {
                background-color: #61dafb; /* Cor de botão do v42.32 */
                color: #282c34; /* Cor de texto do v42.32 */
                border: none;
                padding: 8px 12px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.9em;
                font-weight: bold;
                transition: background-color 0.2s ease, transform 0.1s ease;
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            }
            .purecloud-script-button:hover {
                background-color: #21a1f1; /* Hover do v42.32 */
                transform: translateY(-1px);
            }
            .purecloud-script-button:active {
                transform: translateY(0);
                box-shadow: none;
            }
            .purecloud-script-button.button-danger { background-color: #dc3545; color: #fff; }
            .purecloud-script-button.button-danger:hover { background-color: #c82333; }
            .purecloud-script-button.button-success { background-color: #28a745; }
            .purecloud-script-button.button-error { background-color: #dc3545; }
            .purecloud-script-button.button-secondary { background-color: #555; color: #e0e0e0; border: 1px solid #444; } /* Cor do v42.32 */
            .purecloud-script-button.button-secondary:hover { background-color: #777; } /* Hover do v42.32 */

            .purecloud-script-settings-panel { width: 90%; max-width: 800px; min-height: 500px; height: 85vh; }
            .purecloud-script-quick-reply-popup { width: 90%; max-width: 650px; min-height: 400px; max-height: 75vh; }
            #purecloud-script-notepad-panel, .purecloud-script-manual-panel { width: 400px; height: 350px; }
            #notepad-textarea {
                width: 100%; padding: 8px; border: 1px solid var(--purecloud-script-border-color); resize: none;
                background: var(--purecloud-script-bg-secondary);
                color: var(--purecloud-script-text-primary);
                font-family: 'Segoe UI', Arial, sans-serif;
                font-size: 14px;
                padding: 10px;
                box-sizing: border-box;
                flex-grow: 1; /* Permite que o textarea cresça */
                min-height: 100px;
            }
            .purecloud-script-tabs { display: flex; background: #333; border-bottom: 1px solid #444; } /* Cores do v42.32 */
            .purecloud-script-tab-button {
                background-color: #3a3f47; /* Cor de tab inativa do v42.32 */
                color: #e0e0e0; /* Cor de texto do v42.32 */
                border: none;
                padding: 10px 15px;
                cursor: pointer;
                border-radius: 5px 5px 0 0;
                margin-right: 5px;
                transition: background-color 0.2s ease;
                font-size: 0.95em;
            }
            .purecloud-script-tab-button:hover { background-color: #4a4f57; } /* Hover do v42.32 */
            .purecloud-script-tab-button.active {
                background-color: #282c34; /* Fundo de tab ativa do v42.32 */
                border-bottom: 2px solid #61dafb; /* Borda de tab ativa do v42.32 */
                color: #61dafb; /* Cor de texto de tab ativa do v42.32 */
                font-weight: bold;
            }
            .purecloud-script-tab-content { display: none; padding-top: 15px; flex-direction: column; flex-grow: 1;}
            .purecloud-script-tab-content.active { display: flex; }
            .settings-group { margin-bottom: 20px; }
            .settings-group label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--purecloud-script-text-secondary); }
            .reply-item {
                display: grid; gap: 10px; margin-bottom: 10px; align-items: center;
                border-bottom: 1px solid var(--purecloud-script-border-color); padding-bottom: 10px;
            }
            .reply-item { grid-template-columns: auto 1fr 2fr auto auto; } /* Adicionado uma coluna para o botão copiar */
            .hotkey-group { display: grid; gap: 10px; align-items: center; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid var(--purecloud-script-border-color); grid-template-columns: 1fr 1.5fr auto; }
            .hotkey-group label { margin-bottom: 0; }
            .hotkey-input { cursor: pointer; }
            .clear-hotkey-btn {
                background: var(--purecloud-script-warn-color); color: white; border: none; cursor: pointer;
                border-radius: 50%; width: 24px; height: 24px; font-size: 12px; line-height: 1; display: flex; align-items: center; justify-content: center;
                transition: background-color .2s;
            }
            .clear-hotkey-btn:hover { background-color: #c0392b; }
            .reply-item input[type=text], .reply-item textarea,
            #conversation-target, #inactivity-client-alert-seconds, #inactivity-operator-alert-seconds, #long-convo-alert-min, .hotkey-input,
            #purecloud-script-settings-panel input[type="text"] {
                width: 100%; padding: 8px; border: 1px solid #555; border-radius: 4px; /* Estilo do v42.32 */
                background: #333; /* Fundo de input do v42.32 */
                color: #e0e0e0; /* Texto de input do v42.32 */
                box-sizing: border-box;
            }
            #purecloud-script-settings-panel input[type="color"] {
                width: 80px;
                height: 35px;
                padding: 0;
                border: 1px solid var(--purecloud-script-border-color);
            }
            .reply-item textarea { min-height: 60px; }
            .remove-reply-btn {
                background: var(--purecloud-script-warn-color); color: white; border: none; cursor: pointer;
                border-radius: 50%; width: 28px; height: 28px; font-size: 14px;
                transition: background-color .2s;
            }
            .remove-reply-btn:hover { background-color: #c0392b; }
            .switch { position: relative; display: inline-block; width: 44px; height: 24px; vertical-align: middle; }
            .switch input { opacity: 0; width: 0; height: 0; }
            .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--purecloud-script-border-color); transition: .4s; border-radius: 24px; }
            .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: var(--purecloud-script-bg-primary); transition: .4s; border-radius: 50%; }
            input:checked + .slider { background-color: var(--purecloud-script-accent-color); }
            input:checked + .slider:before { transform: translateX(20px); }

            input.invalid-input {
                border-color: var(--purecloud-script-error-color) !important;
                box-shadow: 0 0 5px var(--purecloud-script-error-color) !important;
            }

            .stats-grid {
                display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 15px; text-align: center; margin-bottom: 20px;
            }
            .stat-item { background: #3a3f47; padding: 15px; border-radius: 8px; } /* Fundo do v42.32 */
            .stat-item span { font-size: 12px; color: #e0e0e0; } /* Cor do v42.32 */
            .stat-item strong { display: block; font-size: 20px; color: #a9f0d1; } /* Cor do v42.32 */
            #analytics-content ul { list-style: none; padding: 0; }
            #analytics-content li { background: var(--purecloud-script-bg-secondary); padding: 8px; border-radius: 4px; margin-bottom: 5px; }
            .achievements-grid { display:flex; flex-wrap:wrap; gap:10px; }
            .achievement-item {
                background: #4a4f57; padding: 10px; border-radius: 8px; /* Fundo do v42.32 */
                text-align: center; width: 120px; opacity: 0.5;
                transition: opacity 0.3s ease;
                border: 1px solid #555; /* Borda do v42.32 */
                display: flex; flex-direction: column; align-items: center;
                justify-content: center;
            }
            .achievement-item.unlocked {
                opacity: 1;
                background-color: #28a745; /* Cor para desbloqueado do v42.32 */
                border-color: #218838;
            }
            .achievement-item.unlocked:hover { transform: scale(1.05); }
            .achievement-item span { font-size: 12px; color: #ccc; margin-top: 5px;} /* Cor do v42.32 */
            .categories-container { padding: 10px 0; display: flex; flex-wrap: wrap; gap: 5px; }
            .category-btn {
                background: #3a3f47; /* Cor do v42.32 */
                border: 1px solid #444; /* Cor do v42.32 */
                border-radius: 15px;
                padding: 5px 12px;
                cursor: pointer;
                font-size: 12px;
                color: #e0e0e0; /* Cor do v42.32 */
                transition: background-color .2s, color .2s, border-color .2s, box-shadow .2s;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            .category-btn:hover {
                background-color: #4a4f57; /* Hover do v42.32 */
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            }
            .category-btn.active {
                background: #61dafb; /* Cor de categoria ativa do v42.32 */
                color: #282c34; /* Cor de texto do v42.32 */
                border-color: #61dafb;
                box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            }
            .category-btn.favorite-btn {
                background: #ffc107; /* Cor do v42.32 */
                border-color: #ffc107;
                color: #333; /* Cor do v42.32 */
            }
            body.gm-dark-mode .category-btn.favorite-btn {
                color: var(--purecloud-script-accent-text);
            }
            .category-btn.favorite-btn.active {
                background: #ffc107;
                color: #333;
            }
            #purecloud-script-quick-reply-search {
                width: 100%; padding: 8px; margin-bottom: 10px; box-sizing: border-box;
                background: #333; /* Fundo do v42.32 */
                color: #e0e0e0; /* Cor do v42.32 */
                border: 1px solid #555; /* Borda do v42.32 */
                border-radius: 4px;
            }
            body.gm-dark-mode #purecloud-script-quick-reply-search::placeholder {
                color: var(--purecloud-script-text-secondary);
            }
            .items-container .item {
                padding: 10px; margin-bottom: 8px; background-color: #3a3f47; /* Fundo do v42.32 */
                border-radius: 5px; cursor: pointer; border-left: 3px solid transparent;
                transition: all .15s;
                color: #e0e0e0; /* Cor do v42.32 */
            }
            .items-container .item strong {
                color: #61dafb; /* Cor do v42.32 */
            }
            .items-container .item small {
                color: #bbb; /* Cor do v42.32 */
            }
            .items-container .item:hover {
                border-left-color: #61dafb; /* Hover do v42.32 */
                background-color: #4a4f57; /* Hover do v42.32 */
            }
            .items-container h4 { margin-top: 15px; margin-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 5px; color: #61dafb; } /* Cores do v42.32 */
            .purecloud-script-notification{
                position:fixed;top:20px;right:20px;padding:10px 20px;border-radius:5px;font-family:Segoe UI,Arial,sans-serif;
                font-size:14px;color:#fff;z-index:10000;opacity:0;transition:opacity .3s;box-shadow:0 2px 10px rgba(0,0,0,.2)
            }
            #purecloud-script-notification-container {
                position: fixed;
                top: 20px;
                right: 20px;
                display: flex;
                flex-direction: column;
                gap: 10px;
                z-index: 10000;
            }
            #purecloud-script-notification-container .purecloud-script-notification {
                position: relative;
                opacity: 1;
                transform: translateX(0);
                transition: opacity 0.3s ease-out, transform 0.3s ease-out;
                box-shadow: 0 2px 10px rgba(0,0,0,.2);
                padding: 10px 20px;
                border-radius: 5px;
                font-family: Segoe UI, Arial, sans-serif;
                font-size: 14px;
                color: #fff;
                max-width: 300px;
            }
            .purecloud-script-notification-info{background-color:var(--purecloud-script-accent-color)}
            .purecloud-script-notification-error{background-color:var(--purecloud-script-error-color)}
            .purecloud-script-notification-warn{background-color:var(--purecloud-script-warn-color)}
            .purecloud-script-notification-success{background-color:var(--purecloud-script-success-color)}
            
            div.interaction-group{position:relative!important;} 

            .injected-bubbles-container {
                position: absolute;
                bottom: 4px;
                left: 10px; 
                transform: none; 
                display: flex;
                gap: 5px;
                z-index: 10;
                pointer-events: none;
                user-select: none;
                width: auto;
                box-sizing: border-box; 
            }
            div.interaction-group > div.interaction-content {
                padding-bottom: 25px !important;
            }

            .chat-message-group > div:last-child > span[data-bind*="elapsedTimeString"],
            .chat-message-group > div:last-child.message-timestamp,
            .chat-message-group .duration,
            .chat-message-group > div:last-child:not([class]):not([data-qa-id]) {
                display: none !important;
            }

            .injected-element {
                font-family: Segoe UI, Arial, sans-serif;
                font-weight: bold;
                font-size: 11px !important;
                padding: 1px 4px !important;
                border-radius: 9999px;
                display: flex;
                align-items: center;
                justify-content: center;
                height: 18px;
                line-height: 1;
                box-shadow: 0 1px 2px rgba(0,0,0,0.1);
                border: none !important;
                transition: background-color 0.2s, color 0.2s, animation 0.2s;
                white-space: nowrap;
            }

            .injected-conversation-number {
                background-color: var(--purecloud-script-bubble-bg-normal) !important;
                color: var(--purecloud-script-bubble-text-normal) !important;
                min-width: 18px;
                padding: 1px 6px !important;
            }
            
            .injected-conversation-timer {
                background-color: var(--purecloud-script-bubble-bg-normal) !important;
                color: var(--purecloud-script-bubble-text-normal) !important;
            }
            .injected-conversation-timer.normal-timer {
                background-color: var(--purecloud-script-bubble-bg-normal) !important;
                color: var(--purecloud-script-bubble-text-normal) !important;
                animation: none !important;
            }

            .injected-conversation-timer.paused-alert {
                background-color: var(--purecloud-script-bubble-bg-paused) !important;
                color: var(--purecloud-script-bubble-text-paused) !important;
                animation: none !important;
            }

            .injected-conversation-timer.inactive-client-alert {
                color: var(--purecloud-script-bubble-text-timer-inactive) !important;
                animation: flash-light 1.5s infinite;
                background-color: var(--purecloud-script-bubble-bg-normal) !important;
            }
            .injected-conversation-timer.inactive-operator-alert {
                color: var(--purecloud-script-bubble-text-operator-inactive) !important;
                background-color: var(--purecloud-script-bubble-bg-normal) !important;
                animation: none !important;
            }

            @keyframes flash-light {
                50% { background-color: #fdd835 !important; color: #222222 !important; }
            }
            
            .injected-checkmark {
                background-color: var(--purecloud-script-bubble-bg-completed) !important;
                color: var(--purecloud-script-bubble-text-completed) !important;
                animation: none !important;
                padding: 1px 6px !important;
                min-width: 18px;
            }

            .interaction-group.is-selected .injected-conversation-number {
                background-color: var(--purecloud-script-bubble-bg-selected) !important;
                color: var(--purecloud-script-bubble-text-selected-number) !important;
            }
            .interaction-group.is-selected .injected-conversation-timer {
                background-color: var(--purecloud-script-bubble-bg-selected) !important;
                color: var(--purecloud-script-bubble-text-selected-timer) !important;
            }
            .interaction-group.is-selected .injected-conversation-timer.inactive-client-alert {
                color: var(--purecloud-script-bubble-text-selected-timer-inactive) !important;
            }
            .interaction-group.is-selected .injected-conversation-timer.paused-alert {
                background-color: var(--purecloud-script-bubble-bg-paused) !important;
                color: var(--purecloud-script-bubble-text-paused) !important;
            }
            .interaction-group.is-selected .injected-conversation-timer.normal-timer {
                background-color: var(--purecloud-script-bubble-bg-selected) !important;
                color: var(--purecloud-script-bubble-text-selected-timer) !important;
                animation: none !important;
            }
            .interaction-group.is-selected .injected-conversation-timer.inactive-operator-alert {
                color: var(--purecloud-script-bubble-text-selected-operator-inactive) !important;
            }
            
            body.gm-dark-mode .injected-checkmark {
                background-color: var(--purecloud-script-bubble-bg-completed) !important;
                color: var(--purecloud-script-bubble-text-completed) !important;
            }
            /* FIM DE ESTILOS INJETADOS */

            /* Estilos para o gráfico de barras */
            .analytics-chart-container-inner {
                display: flex; justify-content: space-between; align-items: flex-end;
                height: 150px; padding: 10px; border: 1px solid var(--purecloud-script-border-color);
                background: var(--purecloud-script-bg-secondary);
                border-radius: 8px;
                margin-top: 15px;
                position: relative;
            }
            .chart-bars-wrapper {
                display: flex; justify-content: space-between; align-items: flex-end;
                width: 100%; height: 100%;
            }
            .chart-bar-wrapper {
                display: flex; flex-direction: column; align-items: center;
                justify-content: flex-end; width: calc(100% / 24); height: 100%;
                margin: 0 1px;
                position: relative;
            }
            .chart-bar {
                width: 80%;
                background-color: var(--purecloud-script-accent-color);
                transition: height 0.3s;
                border-radius: 2px 2px 0 0;
            }
            .bar-count {
                font-size: 10px;
                color: var(--purecloud-script-text-primary);
                margin-bottom: 2px;
                position: absolute; top: -15px;
                transform: translateX(-50%);
                left: 50%;
                white-space: nowrap;
            }
            .bar-count:empty { display: none; }
            .bar-label {
                font-size: 10px;
                color: var(--purecloud-script-text-secondary);
                margin-top: 5px;
                position: absolute; bottom: -20px;
                transform: translateX(-50%);
                left: 50%;
                white-space: nowrap;
            }
            .chart-placeholder {
                text-align: center;
                color: var(--purecloud-script-text-secondary);
                width: 100%;
                margin-top: 50px;
            }
            /* --- ESTILOS DO NOVO MENU --- */
            .purecloud-script-menu-container {
                position: relative;
                display: inline-block;
                order: 4;
                margin-left: 5px;
            }
            .purecloud-script-menu-content {
                display: none;
                position: absolute;
                top: 100%;
                right: 0;
                background-color: var(--purecloud-script-bg-primary);
                min-width: 200px;
                box-shadow: 0px 8px 16px 0px var(--purecloud-script-shadow-color);
                z-index: 1000;
                border-radius: 4px;
                border: 1px solid var(--purecloud-script-border-color);
                padding: 5px 0;
            }
            .purecloud-script-menu-content.active {
                display: block;
            }
            .purecloud-script-menu-item {
                display: flex;
                align-items: center;
                width: 100%;
                text-align: left;
                background: none;
                border: none;
                cursor: pointer;
                font-size: 14px;
                transition: background-color 0.1s;
                box-sizing: border-box;
                color: var(--purecloud-script-text-primary) !important;
                padding: 8px 15px !important;
            }
            .purecloud-script-menu-item:hover {
                background-color: var(--purecloud-script-bg-secondary) !important;
            }
            .purecloud-script-menu-item svg {
                stroke: currentColor;
                width: 18px;
                height: 18px;
                margin-right: 8px;
                flex-shrink: 0;
            }
            .purecloud-script-menu-section-header {
                font-weight: bold;
                color: var(--purecloud-script-text-secondary);
                padding: 8px 15px 5px;
                font-size: 12px;
                border-bottom: 1px solid var(--purecloud-script-border-color);
                margin-bottom: 5px;
                margin-top: 5px;
            }
            .purecloud-script-menu-section-header:first-child {
                margin-top: 0;
            }
            .manual-item {
                background: var(--purecloud-script-bg-secondary);
                padding: 10px;
                border-radius: 5px;
                margin-bottom: 10px;
                font-size: 14px;
                color: var(--purecloud-script-text-primary);
                line-height: 1.4;
            }
            .manual-item strong {
                color: var(--purecloud-script-accent-color);
            }
            /* Estilos para a nova aba de Detalhes */
            .details-grid-header, .details-grid-item {
                display: grid;
                grid-template-columns: 80px 1fr 60px 60px;
                gap: 10px;
                padding: 8px 0;
                border-bottom: 1px solid #444; /* Borda do v42.32 */
                align-items: center;
                font-size: 13px;
                color: #e0e0e0; /* Cor do v42.32 */
            }
            .details-grid-header {
                font-weight: bold;
                color: #61dafb; /* Cor do v42.32 */
                padding-bottom: 5px;
                margin-bottom: 5px;
                border-bottom: 2px solid #61dafb; /* Cor do v42.32 */
            }
            .details-grid-item:hover {
                background-color: #4a4f57; /* Hover do v42.32 */
            }
            .details-client {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .details-time, .details-tma, .details-tme {
                text-align: center;
            }
            .details-list-scroll-container {
                max-height: calc(85vh - 220px);
                overflow-y: auto;
                border: 1px solid #444; /* Borda do v42.32 */
                border-radius: 4px;
                background: #333; /* Fundo do v42.32 */
            }
            .details-list-scroll-container .details-grid-item:last-child {
                border-bottom: none;
            }
            /* Estilos do Mini-Dashboard */
            #purecloud-script-mini-dashboard {
                width: 250px; /* Largura padrão */
                min-width: 200px; /* Largura mínima para ser redimensionável */
                min-height: 100px; /* Altura mínima para ser redimensionável */
                height: auto; /* Permite que a altura se ajuste ao conteúdo */
                bottom: 20px;
                right: 20px;
                top: auto;
                left: auto;
                transform: none;
                margin: 0;
                z-index: 10001;
                resize: both; /* Permite redimensionamento em ambas as direções */
                overflow: hidden; /* Esconde overflow da popup em si, panel-content terá auto */
                padding: 0; /* Remover padding aqui, o panel-content terá */
            }
            #purecloud-script-mini-dashboard.minimized {
                height: 42px !important; /* Altura da header, pode precisar ser ajustada se os ícones forem grandes */
                min-height: 42px !important;
                width: 280px !important; /* Aumentado para garantir visibilidade dos botões */
                min-width: 280px !important; /* Garante que não fique menor que os botões */
                overflow: visible !important; /* Garante que os botões não sejam cortados se ultrapassarem a borda do cabeçalho */
                border-radius: 8px; /* Mantém cantos arredondados */
                bottom: 20px !important; /* Fixa no canto inferior esquerdo */
                left: 20px !important;
                right: auto !important; /* Desabilita right para fixar left */
                top: auto !important; /* Desabilita top para fixar bottom */
                transform: none !important;
            }
            #purecloud-script-mini-dashboard.minimized .panel-content {
                display: none; /* Esconde o conteúdo quando minimizado */
            }
            #purecloud-script-mini-dashboard .panel-content {
                padding: 10px;
                display: flex;
                flex-direction: column;
                flex-grow: 1; /* Permite que o conteúdo cresça e preencha o espaço */
                overflow-y: auto; /* Adiciona scrollbar vertical se o conteúdo for maior */
                height: auto; /* Ajusta a altura automaticamente ao conteúdo, respeitando o flex-grow */
            }
            .mini-dashboard-counter-section { /* Seção para o contador X/Y e botão de ajuste */
                display: flex;
                align-items: center;
                justify-content: space-between;
                background-color: #3a3f47; /* Fundo mais escuro para o contador */
                border: 1px solid #444; /* Borda mais discreta */
                border-radius: 8px; /* Mais arredondado */
                padding: 8px 12px; /* Mais padding */
                margin-bottom: 10px; /* Espaçamento abaixo */
                font-weight: bold;
                color: #a9f0d1; /* Cor mais clara para o texto principal */
                order: 1; /* Para ser o primeiro item no panel-content */
                flex-shrink: 0; /* Não encolher */
            }
            #mini-dashboard-global-counter {
                display: flex;
                align-items: center;
                gap: 8px; /* Mais espaçamento entre elementos */
                flex-grow: 1;
            }
            #mini-dashboard-global-counter .counter-text {
                font-size: 1.2em; /* Texto maior para o contador */
                color: #a9f0d1; /* Mesma cor do strong do stats-grid */
            }
            #mini-dashboard-global-counter .progress-bar-container {
                width: 80px; /* Barra de progresso mais larga */
                height: 10px; /* Mais alta */
                margin-left: 5px;
                background-color: #555; /* Fundo da barra de progresso */
            }
            #mini-dashboard-global-counter .progress-bar {
                background-color: #61dafb; /* Cor da barra de progresso (azul do v42.32) */
            }
            /* Botão de Ajuste no mini-dashboard */
            #mini-dashboard-adjust-attended-btn {
                padding: 4px 8px; /* Mais compacto */
                font-size: 0.9em;
                margin-left: 8px;
                background-color: #61dafb; /* Cor do botão principal */
                color: #282c34;
                flex-shrink: 0; /* Não encolher */
            }
            #mini-dashboard-adjust-attended-btn:hover {
                background-color: #21a1f1;
            }
            #mini-dashboard-adjust-attended-btn svg {
                margin-right: 0; /* Remove margin para ícone sozinho */
            }
            /* Ajuste para a grid de stats para aparecer APÓS o contador X/Y */
            #purecloud-script-mini-dashboard .stats-grid {
                order: 2; /* Depois do contador X/Y */
                margin-top: 15px; /* Adiciona um espaço acima */
                grid-template-columns: 1fr; /* Coluna única para verticalidade como na imagem */
                flex-shrink: 0; /* Não encolher */
            }
            /* Ajuste dos itens da stats-grid para alinhamento e espaçamento */
            #purecloud-script-mini-dashboard .stats-grid .stat-item {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px 15px;
                border-bottom: 1px solid #444; /* Linha divisória */
                background: #282c34; /* Fundo escuro como o painel */
                border-radius: 4px;
            }
            #purecloud-script-mini-dashboard .stats-grid .stat-item:last-child {
                border-bottom: none; /* Remove borda do último */
            }
            #purecloud-script-mini-dashboard .stats-grid .stat-item span {
                font-size: 0.9em;
                color: #e0e0e0;
            }
            #purecloud-script-mini-dashboard .stats-grid .stat-item strong {
                font-size: 1.1em;
                color: #a9f0d1;
            }


            /* Estilos de inputs de cor */
            #purecloud-script-settings-panel #tab-colors label {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 10px;
            }
            #purecloud-script-settings-panel #tab-colors input[type="color"] {
                width: 80px;
                height: 30px;
                border: none;
                padding: 0;
            }
            #purecloud-script-settings-panel #tab-colors .settings-group {
                border-bottom: 1px solid var(--purecloud-script-border-color);
                padding-bottom: 10px;
                margin-bottom: 10px;
            }
            #purecloud-script-settings-panel #tab-colors .settings-group:last-of-type {
                border-bottom: none;
                margin-bottom: 0;
            }
            /* Destaque de links e IDs no chat */
            .purecloud-script-highlighted-link {
                color: #61dafb !important; /* Cor do v42.32 */
                font-weight: bold;
                text-decoration: underline;
                cursor: pointer;
            }
            .purecloud-script-highlighted-link:hover {
                opacity: 0.8;
            }
            .purecloud-script-highlighted-id {
                background-color: rgba(97, 218, 251, 0.2); /* Fundo sutil para IDs do v42.32 */
                border-radius: 3px;
                padding: 1px 3px;
                font-weight: bold;
                cursor: pointer;
                color: #61dafb; /* Cor do v42.32 */
            }
            .purecloud-script-highlighted-id:hover {
                background-color: rgba(97, 218, 251, 0.4);
            }
            .chart-scroll-container {
                overflow-x: auto;
                padding-bottom: 30px;
            }
            .chart-scroll-container .chart-bars-wrapper {
                width: 240%;
                min-width: 700px;
            }
            .chart-scroll-container::-webkit-scrollbar {
                height: 8px;
            }
            .chart-scroll-container::-webkit-scrollbar-thumb {
                background-color: var(--purecloud-script-text-secondary);
                border-radius: 4px;
            }
            .chart-scroll-container::-webkit-scrollbar-track {
                background-color: var(--purecloud-script-bg-secondary);
            }
            body.gm-dark-mode .chart-scroll-container::-webkit-scrollbar-thumb {
                background-color: var(--purecloud-script-text-secondary);
            }
            body.gm-dark-mode .chart-scroll-container::-webkit-scrollbar-track {
                background-color: var(--purecloud-script-bg-secondary);
            }
        `;
        const style = document.createElement('style'); style.id = 'purecloud-script-injected-style'; document.head.appendChild(style);
        style.textContent = css;
    }

    const initializeDailyCounters = (forceReset = false) => {
        const today = getBrazilTime(new Date()).toLocaleDateString('pt-BR');
        // Verifica se a data da última atividade salva é diferente de hoje ou se um reset forçado foi solicitado
        if (localStorage.getItem('purecloudScript_lastActivityDate') !== today || forceReset) {
            log("Resetando contadores diários e conquistas.");
            localStorage.setItem('purecloudScript_lastActivityDate', today); // Atualiza a data da última atividade
            analyticsManager.clearAllData(); // Isso já zera os contadores e conquistas no localStorage
        } else {
            // Se a data for a mesma, carrega os valores persistidos
            const data = analyticsManager.getData();
            // completedConversationsCount agora é extraído do analyticsManager, filtrando as conversas com duração >= threshold
            completedConversationsCount = data.conversations.filter(c => c.duration >= CONFIG.CHECKMARK_THRESHOLD_MS).length;
            dailyDocCopies = data.docCopies;
            dailyHotkeysUsed = new Set(data.hotkeysUsed);
        }
        log(`Contadores diários inicializados/carregados. Conversas: ${completedConversationsCount}, Docs Copiados: ${dailyDocCopies}`);
    };

    // --- EXECUÇÃO INICIAL ---
    const initialize = () => {
        initializeDailyCounters(); // Inicializa/reseta os contadores e analytics ao carregar o script
        const currentScriptVersion = '42.53'; // Atualiza a versão para refletir as últimas mudanças

        // Carrega configurações e aplica o modo escuro antes de injetar CSS e exibir notificação
        saveData(); // Salva as configs para garantir que o darkMode e cores estejam atualizados
        injectCss(); // Injete o CSS que usa as CONFIG.TIMER_COLORS e CONFIG.DARK_MODE

        // Exibe notificação de boas-vindas/atualização se a versão mudou
        if (CONFIG.LAST_SCRIPT_VERSION !== currentScriptVersion) {
            UI.createNotification(`Script PureCloud V${currentScriptVersion} carregado! Mini-Dashboard e Analytics corrigidos.`, 'info', 10000); // Mensagem atualizada
            log(`Mensagem de boas-vindas/atualização para a versão ${currentScriptVersion} exibida.`);
        } else {
            log(`Script PureCloud V${currentScriptVersion} já em execução.`);
        }

        // Adiciona o ouvinte de eventos de teclado para atalhos
        document.addEventListener('keydown', keyboardEventHandler);

        // Tenta encontrar o contêiner da lista de conversas, ou fallback para o body
        let targetNode = findEl(CONFIG.PURECLOUD_SELECTORS.CONVERSATION_LIST_CONTAINER);
        if (!targetNode) {
            targetNode = document.body;
            log("WARN: Contêiner da lista de conversas não encontrado com seletores específicos. Observando document.body (menos eficiente).");
        } else {
            log("Contêiner da lista de conversas encontrado. Observando elemento específico.");
        }

        // Inicia o MutationObserver para monitorar mudanças na lista de conversas
        const mainObserver = new MutationObserver(throttle(mainLoop, CONFIG.MAIN_LOOP_THROTTLE_MS));
        mainObserver.observe(targetNode, { childList: true, subtree: true, attributes: false });

        // Chama o mainLoop algumas vezes no início para garantir que a UI seja criada
        setTimeout(mainLoop, 500);
        setTimeout(mainLoop, 2500);
        setTimeout(mainLoop, 5000);

        // Cria o mini-dashboard ao iniciar o script, se estiver configurado para ser visível
        if (CONFIG.MINI_DASHBOARD_VISIBLE) {
            UI.createMiniDashboard();
        }
    };

    // Verifica o estado de carregamento do DOM e chama initialize
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }

    // Expor funções globais para depuração ou interação manual, se necessário
    window.purecloudScript = {
        CONFIG, // Objeto de configuração
        analyticsManager, // Gerenciador de analytics e conquistas
        UI, // Funções de interface do usuário
        actions, // Ações de atalho
        log, // Função de log
        saveData, // Função para salvar dados
        initializeDailyCounters, // Função para inicializar contadores
        // updateGlobalCounterText foi removida, o mini-dashboard agora é o ponto central
    };

    log("Script PureCloud V42.53 carregado com sucesso e pronto para uso.");
})();

/*
 * Script Independente: Trava de Encerramento de Conversa (v1.1 - Posicionamento do Botão)
 * Criado por: Josias Queiroz Xavier (Kingoffjoss Assessoria)
 * Adaptado e Isolado por: Gemini (Google) / Parceiro de Programacao
 * Instruções: Cole este código no console do desenvolvedor (F12) na página do PureCloud.
 *
 * Funcionalidade: Adiciona um botão de "escudo" que bloqueia o botão "Encerrar"
 * para evitar cliques acidentais. O botão de trava agora é posicionado
 * diretamente ao lado do botão de encerrar.
 */

(function() {
    'use strict';

    // --- Verificação para não executar o script múltiplas vezes ---
    if (window.LOCKDOWN_SCRIPT_LOADED_V1_1) {
        console.log("[LOCKDOWN SCRIPT] O script de trava v1.1 já está em execução.");
        return;
    }
    window.LOCKDOWN_SCRIPT_LOADED_V1_1 = true;

    console.log("[LOCKDOWN SCRIPT] Iniciando v1.1...");

    // --- Configuração Essencial ---
    const CONFIG = {
        MAIN_LOOP_THROTTLE_MS: 1000,
        PURECLOUD_SELECTORS: {
            TOOLBAR: ['div.interaction-controls-primary', 'div[data-qa-id="interaction-controls-primary"]'],
            INTERACTION_GROUP: ['div.interaction-group', 'div[data-qa-id="interaction-group-list-item"]'],
            SELECTED_INTERACTION_GROUP: ['div.interaction-group.is-selected', 'div[data-qa-id="interaction-group-list-item"].is-selected'],
        },
        LOCKDOWN_BUTTON: {
            REQUIRED_CLICKS: 5,
            END_CHAT_BUTTON_SELECTOR: 'button[aria-label="Mensagens de término"], button[data-qa-id="interaction-control-disconnect"]',
        }
    };

    // --- Armazenamento de Estado ---
    const conversationStates = new Map();

    // --- Funções de Utilidade ---
    const findEl = (selectors, parent = document) => {
        if (!Array.isArray(selectors)) selectors = [selectors];
        for (const selector of selectors) {
            const el = parent.querySelector(selector);
            if (el) return el;
        }
        return null;
    };

    const throttle = (func, limit) => {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    };

    const UI = {
        createNotification(message, type = 'info', duration = 3000) {
            let container = document.getElementById('lockdown-script-notification-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'lockdown-script-notification-container';
                document.body.appendChild(container);
            }
            const n = document.createElement("div");
            n.textContent = message;
            n.className = `lockdown-script-notification lockdown-script-notification-${type}`;
            container.prepend(n);
            setTimeout(() => {
                n.style.opacity = '0';
                setTimeout(() => n.remove(), 300);
            }, duration);
        }
    };

    // --- Ação do Botão ---
    const actions = {
        toggleConversationLock: () => {
            const selectedConvEl = findEl(CONFIG.PURECLOUD_SELECTORS.SELECTED_INTERACTION_GROUP);
            if (!selectedConvEl) {
                UI.createNotification("Por favor, selecione uma conversa para destravar.", "warn");
                return;
            }
            const convState = conversationStates.get(selectedConvEl);
            if (!convState) return;

            const lockButton = document.getElementById('lockdown-script-btn-toggleLock');
            if (lockButton) {
                lockButton.classList.add('btn-feedback-click');
                setTimeout(() => lockButton.classList.remove('btn-feedback-click'), 200);
            }

            if (!convState.isLocked) {
                UI.createNotification("Esta conversa já está destravada.", "info", 2000);
                return;
            }

            convState.unlockClicks++;
            const clicksRemaining = CONFIG.LOCKDOWN_BUTTON.REQUIRED_CLICKS - convState.unlockClicks;

            if (clicksRemaining > 0) {
                UI.createNotification(`Clique mais ${clicksRemaining} vez(es) para destravar.`, "info", 1500);
            } else {
                convState.isLocked = false;
                UI.createNotification("Conversa destravada! O botão 'Encerrar' foi liberado.", "success");
                mainLoop();
            }
        }
    };

    // --- Criação da Interface ---
    function createToolbarUI(toolbar) {
        if (toolbar.querySelector('#lockdown-script-btn-toggleLock')) return;

        const ICON_SHIELD_LOCKED = '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>';
        
        const btn = document.createElement("button");
        btn.id = 'lockdown-script-btn-toggleLock';
        btn.className = 'lockdown-script-custom-btn';
        btn.title = 'Controle de Encerramento de Conversa';
        btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${ICON_SHIELD_LOCKED}</svg>`;
        btn.onclick = actions.toggleConversationLock;
        
        // [MODIFICAÇÃO] Lógica para posicionar o botão
        // 1. Encontra o botão de encerrar como referência
        const endChatButton = findEl(CONFIG.LOCKDOWN_BUTTON.END_CHAT_BUTTON_SELECTOR, toolbar);

        // 2. Se encontrar o botão de referência, insere o nosso botão de trava antes dele.
        if (endChatButton) {
            endChatButton.parentNode.insertBefore(btn, endChatButton);
        } else {
            // 3. Se não encontrar (por segurança), adiciona no início da barra.
            toolbar.prepend(btn);
        }
    }

    // --- Loop Principal ---
    function mainLoop() {
        // (O Loop Principal permanece o mesmo, pois a lógica de atualização já é robusta)
        const toolbar = findEl(CONFIG.PURECLOUD_SELECTORS.TOOLBAR);
        if (toolbar) { createToolbarUI(toolbar); }

        const endChatButton = findEl(CONFIG.LOCKDOWN_BUTTON.END_CHAT_BUTTON_SELECTOR);
        const conversations = document.querySelectorAll(CONFIG.PURECLOUD_SELECTORS.INTERACTION_GROUP.join(', '));
        const activeConversations = new Set(conversations);
        let isAnyConversationSelected = false;

        conversationStates.forEach((state, el) => {
            if (!activeConversations.has(el)) {
                conversationStates.delete(el);
            }
        });

        conversations.forEach(conv => {
            if (!conversationStates.has(conv)) {
                conversationStates.set(conv, { isLocked: true, unlockClicks: 0 });
            }

            const isSelected = conv.classList.contains('is-selected');
            if (isSelected) {
                isAnyConversationSelected = true;
                const convState = conversationStates.get(conv);
                const lockButton = document.getElementById('lockdown-script-btn-toggleLock');

                if (convState && lockButton) {
                    const ICON_SHIELD_LOCKED = '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>';
                    const ICON_SHIELD_UNLOCKED = '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path><path d="M9 12l2 2 4-4"></path>';
                    
                    if (convState.isLocked) {
                        lockButton.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${ICON_SHIELD_LOCKED}</svg>`;
                        lockButton.title = `Destravar Encerrar (Faltam ${CONFIG.LOCKDOWN_BUTTON.REQUIRED_CLICKS - convState.unlockClicks} cliques)`;
                        if (endChatButton) {
                            endChatButton.disabled = true;
                            endChatButton.classList.add('lockdown-disabled');
                            endChatButton.title = 'Botão bloqueado. Clique no escudo para liberar.';
                        }
                    } else {
                        lockButton.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">${ICON_SHIELD_UNLOCKED}</svg>`;
                        lockButton.title = "Conversa Destravada";
                        if (endChatButton) {
                            endChatButton.disabled = false;
                            endChatButton.classList.remove('lockdown-disabled');
                            endChatButton.title = 'Mensagens de término';
                        }
                    }
                }
            }
        });
        
        if (endChatButton && !isAnyConversationSelected) {
            endChatButton.disabled = true;
            endChatButton.classList.add('lockdown-disabled');
            endChatButton.title = 'Selecione uma conversa';
        }
    }

    // --- Estilos CSS ---
    function injectCss() {
        if (document.getElementById('lockdown-script-injected-style')) return;
        const css = `
            .lockdown-script-custom-btn {
                background: #f0f0f0 !important; border: 1px solid #dddddd !important;
                padding: 8px 12px !important; margin: 0 4px !important; cursor: pointer; display: inline-flex;
                align-items: center; transition: all .2s; height: 38px; border-radius: 4px;
                /* [MODIFICAÇÃO] A propriedade 'order' foi removida para permitir o posicionamento pelo código */
            }
            .lockdown-script-custom-btn:hover {
                box-shadow: 0 0 8px #4CAF50; transform: translateY(-1px);
            }
            .lockdown-script-custom-btn svg { stroke: #555555 !important; width: 22px; height: 22px; }
            .lockdown-script-custom-btn.btn-feedback-click { animation: pulse-feedback 0.2s ease-out; }
            @keyframes pulse-feedback {
                0% { transform: scale(1); }
                50% { transform: scale(0.9); background-color: #4CAF50; }
                100% { transform: scale(1); }
            }
            button.lockdown-disabled {
                opacity: 0.5 !important; cursor: not-allowed !important; filter: grayscale(80%);
                transition: opacity 0.2s, filter 0.2s;
            }
            #lockdown-script-notification-container { position: fixed; top: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; z-index: 10002; }
            .lockdown-script-notification {
                padding: 10px 20px; border-radius: 5px; font-family: Segoe UI, Arial, sans-serif;
                font-size: 14px; color: #fff; box-shadow: 0 2px 10px rgba(0,0,0,.2);
                opacity: 1; transform: translateX(0); transition: opacity 0.3s, transform 0.3s;
            }
            .lockdown-script-notification-info { background-color: #2196F3; }
            .lockdown-script-notification-warn { background-color: #f44336; }
            .lockdown-script-notification-success { background-color: #4CAF50; }
        `;
        const style = document.createElement('style');
        style.id = 'lockdown-script-injected-style';
        style.textContent = css;
        document.head.appendChild(style);
    }

    // --- Inicialização ---
    function initialize() {
        injectCss();
        const targetNode = findEl(CONFIG.PURECLOUD_SELECTORS.CONVERSATION_LIST_CONTAINER) || document.body;
        const mainObserver = new MutationObserver(throttle(mainLoop, CONFIG.MAIN_LOOP_THROTTLE_MS));
        mainObserver.observe(targetNode, { childList: true, subtree: true, attributes: true });
        setTimeout(mainLoop, 1500);
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initialize);
    } else {
        initialize();
    }
})();
/*
 * Script de Automação: Botão de Atalho para Desconectar (Versão Corrigida)
 * Criado por: Josias Queiroz Xavier (Kingoffjoss Assessoria) e Parceiro de Programacao (Gemini)
 *
 * Funcionalidade: Adiciona um botão de atalho (Power Off) na barra de ferramentas principal.
 * Ao ser clicado, este botão aciona automaticamente o botão de "Desconectar" da conversa.
 */
(function() {
    'use strict';

    // --- Verificação para não executar o script múltiplas vezes ---
    if (window.DISCONNECT_SHORTCUT_SCRIPT_LOADED) {
        console.log("[DESCONECTAR SCRIPT] O script já está em execução.");
        return;
    }
    window.DISCONNECT_SHORTCUT_SCRIPT_LOADED = true;

    console.log("[DESCONECTAR SCRIPT] Script de atalho para desconectar iniciado.");

    // --- Configuração Essencial ---
    const CONFIG = {
        // Seletor da barra de ferramentas onde o botão será adicionado.
        BUTTON_CONTAINER_SELECTOR: ['div.interaction-controls-primary', 'div[data-qa-id="interaction-controls-primary"]'],

        // [AJUSTADO] Seletor robusto para o botão de Desconectar/Encerrar.
        TARGET_BUTTON_SELECTOR: 'button[aria-label="Mensagens de término"], button[data-qa-id="interaction-control-disconnect"]',

        // [AJUSTADO] Configurações de aparência do nosso botão de atalho.
        NEW_BUTTON_ID: 'shortcut-disconnect-btn',
        NEW_BUTTON_TITLE: 'Atalho para Desconectar', // Título mais claro
        NEW_BUTTON_ICON: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line></svg>', // Ícone de "power off"
    };

    // --- Funções de Utilidade ---
    const findEl = (selectors, parent = document) => {
        if (!Array.isArray(selectors)) selectors = [selectors];
        for (const selector of selectors) {
            const el = parent.querySelector(selector);
            if (el) return el;
        }
        return null;
    };

    // --- Lógica Principal: Clicar no botão alvo ---
    function clickTargetButton() {
        const targetButton = findEl(CONFIG.TARGET_BUTTON_SELECTOR);
        if (targetButton) {
            targetButton.click();
            const newBtn = document.getElementById(CONFIG.NEW_BUTTON_ID);
            if (newBtn) {
                newBtn.classList.add('btn-feedback-click');
                setTimeout(() => newBtn.classList.remove('btn-feedback-click'), 300);
            }
        } else {
            alert(`Erro: O botão de Desconectar (seletor: "${CONFIG.TARGET_BUTTON_SELECTOR}") não foi encontrado na página.`);
        }
    }

    // --- Criação do Botão na Interface ---
    function createShortcutButton(container) {
        if (document.getElementById(CONFIG.NEW_BUTTON_ID)) return;

        const btn = document.createElement("button");
        btn.id = CONFIG.NEW_BUTTON_ID;
        btn.className = 'evaluation-script-custom-btn'; // Reutilizando a classe de estilo
        btn.title = CONFIG.NEW_BUTTON_TITLE;
        btn.innerHTML = CONFIG.NEW_BUTTON_ICON;
        btn.onclick = clickTargetButton;
        container.prepend(btn); // Adiciona o botão no início da barra
    }

    // --- Loop Principal para adicionar o botão ---
    function mainLoop() {
        const container = findEl(CONFIG.BUTTON_CONTAINER_SELECTOR);
        if (container) {
            createShortcutButton(container);
        }
    }

    // --- Estilos CSS para o botão ---
    function injectCss() {
        if (document.getElementById('evaluation-script-injected-style-final')) return;
        const style = document.createElement('style');
        style.id = 'evaluation-script-injected-style-final';
        style.textContent = `
            .evaluation-script-custom-btn { background: #f0f0f0 !important; border: 1px solid #dddddd !important; padding: 8px 12px !important; margin: 0 4px !important; cursor: pointer; display: inline-flex !important; align-items: center; transition: all .2s; height: 38px; border-radius: 4px; }
            .evaluation-script-custom-btn:hover { box-shadow: 0 0 8px #dc3545; transform: translateY(-1px); } /* Sombra vermelha no hover */
            .evaluation-script-custom-btn svg { stroke: #555555 !important; width: 22px; height: 22px; }
            .evaluation-script-custom-btn.btn-feedback-click { animation: pulse-feedback-eval 0.3s ease-out; }
            @keyframes pulse-feedback-eval { 0% { transform: scale(1); } 50% { transform: scale(0.9); background-color: #dc3545; } 100% { transform: scale(1); } } /* Animação com cor vermelha */
        `;
        document.head.appendChild(style);
    }

    // --- Inicialização do script ---
    function initialize() {
        injectCss();
        const mainInterval = setInterval(() => {
            if (findEl(CONFIG.BUTTON_CONTAINER_SELECTOR)) {
                mainLoop();
                clearInterval(mainInterval);
            }
        }, 1500);
    }

    initialize();
})();

